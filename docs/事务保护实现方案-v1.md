# äº‹åŠ¡ä¿æŠ¤å®ç°æ–¹æ¡ˆï¼ˆå®Œæ•´ç‰ˆï¼‰

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.1  
> **åˆ›å»ºæ—¶é—´**: 2025-01-12  
> **æœ€åæ›´æ–°**: 2025-01-12  
> **ç»´æŠ¤è€…**: game14.cn  
> **çŠ¶æ€**: æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½ï¼ˆå«é‚®ä»¶å‘Šè­¦ï¼‰å·²å®æ–½å®Œæˆ âœ…
> **å…³è”æ–‡æ¡£**:
>
> - [ç³»ç»Ÿäº¤æ˜“æµç¨‹ä¸çŠ¶æ€ç®¡ç†åˆ†æ.md](./ç³»ç»Ÿäº¤æ˜“æµç¨‹ä¸çŠ¶æ€ç®¡ç†åˆ†æ.md)
> - [è‡ªåŠ¨æ­¢æŸå•ç³»ç»Ÿ - å®ç°è¯´æ˜.md](./è‡ªåŠ¨æ­¢æŸå•ç³»ç»Ÿ%20-%20å®ç°è¯´æ˜.md)

---

## ğŸ“‹ ç›®å½•

1. [é—®é¢˜æ¦‚è¿°](#é—®é¢˜æ¦‚è¿°)
2. [æ¶æ„æ·±åº¦åˆ†æ](#æ¶æ„æ·±åº¦åˆ†æ)
3. [æ ¸å¿ƒä¸šåŠ¡æµç¨‹](#æ ¸å¿ƒä¸šåŠ¡æµç¨‹)
4. [äº‹åŠ¡ä¿æŠ¤æ–¹æ¡ˆ](#äº‹åŠ¡ä¿æŠ¤æ–¹æ¡ˆ)
5. [å¤šäº¤æ˜“æ‰€å…¼å®¹æ€§](#å¤šäº¤æ˜“æ‰€å…¼å®¹æ€§)
6. [å¼‚å¸¸çŠ¶æ€ç®¡ç†](#å¼‚å¸¸çŠ¶æ€ç®¡ç†)
7. [å¥åº·æ£€æŸ¥ç³»ç»Ÿ](#å¥åº·æ£€æŸ¥ç³»ç»Ÿ)
8. [å®æ–½æ­¥éª¤](#å®æ–½æ­¥éª¤)

---

## é—®é¢˜æ¦‚è¿°

### å½“å‰ç³»ç»Ÿæ¶æ„ç¼ºé™·

å½“å‰ç³»ç»Ÿåœ¨æ‰§è¡Œ**å¹³ä»“æ“ä½œ**å’Œ**æ¡ä»¶å•è§¦å‘å¤„ç†**æ—¶ï¼Œæ•°æ®åº“æ“ä½œæ˜¯**é€ä¸ªç‹¬ç«‹æ‰§è¡Œ**çš„ï¼Œç¼ºä¹äº‹åŠ¡ä¿æŠ¤ã€‚è¿™å¯¼è‡´å¦‚æœæŸä¸ªæ­¥éª¤å¤±è´¥ï¼Œä¼šé€ æˆ**æ•°æ®ä¸ä¸€è‡´**ï¼Œç‰¹åˆ«æ˜¯ï¼š

#### 1. æŒä»“è®°å½•åœ¨æœ€åæ‰åˆ é™¤

```typescript
// âŒ å½“å‰å®ç°ï¼ˆæœ‰é—®é¢˜ï¼‰
await dbClient.execute(`INSERT INTO trades ...`);                  // æ­¥éª¤1
await dbClient.execute(`INSERT INTO position_close_events ...`);   // æ­¥éª¤2
await exchangeClient.cancelPositionStopLoss(contract);             // æ­¥éª¤3
await dbClient.execute(`UPDATE price_orders SET status='cancelled'...`); // æ­¥éª¤4
await dbClient.execute(`DELETE FROM positions WHERE symbol=?...`); // æ­¥éª¤5 âŒ æœ€åæ‰åˆ é™¤!
```

**é£é™©**ï¼šå¦‚æœæ­¥éª¤3-5ä»»ä½•ä¸€æ­¥å¤±è´¥ï¼Œ`positions` è¡¨ä»ä¿ç•™æŒä»“è®°å½•ï¼Œå¯¼è‡´ï¼š

- AI Agent è¯¯è®¤ä¸ºæŒä»“ä»å­˜åœ¨ï¼Œç»§ç»­å‘å‡ºç®¡ç†æŒ‡ä»¤
- å‰ç«¯æ˜¾ç¤ºæŒä»“ä½†å®é™…å·²å¹³ä»“
- æ¡ä»¶å•ç›‘æ§æœåŠ¡å°è¯•ç®¡ç†ä¸å­˜åœ¨çš„æŒä»“
- å¯èƒ½è§¦å‘é‡å¤å¹³ä»“ï¼Œå¯¼è‡´"ä»“ä½ä¸å­˜åœ¨"é”™è¯¯

#### 2. äº¤æ˜“æ‰€æ“ä½œä¸æ•°æ®åº“æ“ä½œæ··åˆ

```typescript
// âŒ å³ä½¿ä½¿ç”¨äº‹åŠ¡ä¹Ÿæ— æ³•å›æ»šäº¤æ˜“æ‰€æ“ä½œ
await dbClient.execute('BEGIN TRANSACTION');
try {
  await dbClient.execute(`INSERT INTO trades ...`);
  await exchangeClient.cancelPositionStopLoss(contract); // âš ï¸ äº¤æ˜“æ‰€æ“ä½œæ— æ³•å›æ»š!
  await dbClient.execute(`UPDATE price_orders ...`);
  await dbClient.execute('COMMIT');
} catch (error) {
  await dbClient.execute('ROLLBACK'); // ä½†äº¤æ˜“æ‰€çš„å–æ¶ˆæ“ä½œå·²ç»æ‰§è¡Œäº†!
}
```

**é—®é¢˜**ï¼šäº¤æ˜“æ‰€APIè°ƒç”¨ä¸æ”¯æŒå›æ»šï¼Œä¸€æ—¦æ‰§è¡Œå°±ç”Ÿæ•ˆï¼Œæ•°æ®åº“å›æ»šæ— æ³•æ’¤é”€äº¤æ˜“æ‰€çŠ¶æ€å˜æ›´ã€‚

#### 3. ç¼ºä¹å¼‚å¸¸çŠ¶æ€è®°å½•

å½“äº¤æ˜“æ‰€æ“ä½œæˆåŠŸä½†æ•°æ®åº“æ“ä½œå¤±è´¥æ—¶ï¼Œç³»ç»Ÿæ— æ³•è¿½è¸ªè¿™ç§**ä¸ä¸€è‡´çŠ¶æ€**ï¼Œå¯¼è‡´ï¼š

- æ— æ³•è‡ªåŠ¨æ¢å¤
- éš¾ä»¥å®šä½é—®é¢˜
- éœ€è¦äººå·¥ä»‹å…¥æ—¶ç¼ºä¹ä¾æ®

#### 4. å¤šäº¤æ˜“æ‰€é€‚é…å·®å¼‚

- **Gate.io**ï¼šåå‘åˆçº¦ï¼ˆinverseï¼‰ï¼Œæ•°é‡å•ä½æ˜¯"å¼ "ï¼Œéœ€è¦åˆçº¦ä¹˜æ•°ï¼ˆquanto multiplierï¼‰
- **Binance**ï¼šæ­£å‘åˆçº¦ï¼ˆlinearï¼‰ï¼Œæ•°é‡å•ä½æ˜¯"å¸"ï¼Œç›´æ¥è®¡ç®—

ä¸åŒäº¤æ˜“æ‰€åœ¨ç²¾åº¦ã€æ•°é‡è®¡ç®—ã€APIå“åº”æ ¼å¼ä¸Šçš„å·®å¼‚ï¼Œå¢åŠ äº†äº‹åŠ¡ä¿æŠ¤çš„å¤æ‚æ€§ã€‚

---

## æ¶æ„æ·±åº¦åˆ†æ

### ç³»ç»Ÿæ ¸å¿ƒç»„ä»¶å…³ç³»å›¾

```bash
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Trading Loop äº¤æ˜“å¾ªç¯                      â”‚
â”‚                    (src/scheduler/tradingLoop.ts)               â”‚
â”‚  - å®šæ—¶è§¦å‘ AI å†³ç­– (æ¯60ç§’)                                     â”‚
â”‚  - æ”¶é›†å¸‚åœºæ•°æ® (Kçº¿ã€æŒ‡æ ‡ã€è®¢å•ç°¿)                               â”‚
â”‚  - å‘¨æœŸæ€§åŒæ­¥æŒä»“çŠ¶æ€ (æ¯5åˆ†é’Ÿ)                                   â”‚
â”‚  - å¼ºåˆ¶é£æ§æ£€æŸ¥ (æŒä»“æ•°é‡ã€æ€»æ•å£ã€å›æ’¤)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚                              â”‚
               â”‚ AIå†³ç­–è§¦å‘                     â”‚ å®šæ—¶åŒæ­¥
               â”‚                              â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  Trading Agent â”‚           â”‚  Condition Monitor     â”‚
       â”‚   AIä»£ç†å·¥å…·   â”‚           â”‚   æ¡ä»¶å•ç›‘æ§æœåŠ¡       â”‚
       â”‚ (tradingAgent) â”‚           â”‚ (priceOrderMonitor)    â”‚
       â”‚                â”‚           â”‚                        â”‚
       â”‚ - openPosition â”‚           â”‚ - æ¯30ç§’æ£€æµ‹è§¦å‘       â”‚
       â”‚ - closePositionâ”‚           â”‚ - æ›´æ–°æ¡ä»¶å•çŠ¶æ€       â”‚
       â”‚ - setStopLoss  â”‚           â”‚ - è®°å½•å¹³ä»“äº‹ä»¶         â”‚
       â”‚ - partialClose â”‚           â”‚ - æ¸…ç†å­¤å„¿è®¢å•         â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚                              â”‚
               â”‚ è°ƒç”¨äº¤æ˜“æ‰€API                  â”‚ æŸ¥è¯¢æˆäº¤è®°å½•
               â”‚                              â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚        Exchange Client äº¤æ˜“æ‰€æ¥å£æŠ½è±¡å±‚              â”‚
       â”‚          (src/exchanges/IExchangeClient)            â”‚
       â”‚                                                      â”‚
       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
       â”‚  â”‚ Gate.io Client  â”‚      â”‚ Binance Client   â”‚    â”‚
       â”‚  â”‚ (åå‘åˆçº¦)      â”‚      â”‚ (æ­£å‘åˆçº¦)       â”‚    â”‚
       â”‚  â”‚ - å¼ æ•°è®¡ç®—      â”‚      â”‚ - å¸æ•°é‡è®¡ç®—      â”‚    â”‚
       â”‚  â”‚ - quantoä¹˜æ•°    â”‚      â”‚ - ç²¾åº¦å¤„ç†       â”‚    â”‚
       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
       â”‚                                                      â”‚
       â”‚  - placeOrder (ä¸‹å•)                                â”‚
       â”‚  - setPositionStopLoss (è®¾ç½®æ¡ä»¶å•)                 â”‚
       â”‚  - cancelPositionStopLoss (å–æ¶ˆæ¡ä»¶å•)              â”‚
       â”‚  - getPositions (æŸ¥è¯¢æŒä»“)                          â”‚
       â”‚  - getPriceOrders (æŸ¥è¯¢æ¡ä»¶å•)                      â”‚
       â”‚  - getMyTrades (æŸ¥è¯¢æˆäº¤è®°å½•)                       â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â”‚ åŒå‘åŒæ­¥
                          â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚            Database Layer æ•°æ®åº“å±‚ (LibSQL)          â”‚
       â”‚          (src/database/*.ts)                        â”‚
       â”‚                                                      â”‚
       â”‚  æ ¸å¿ƒè¡¨ç»“æ„:                                          â”‚
       â”‚  - trades                  (äº¤æ˜“è®°å½•)               â”‚
       â”‚  - positions               (æŒä»“è®°å½•)               â”‚
       â”‚  - price_orders            (æ¡ä»¶å•)                 â”‚
       â”‚  - position_close_events   (å¹³ä»“äº‹ä»¶)               â”‚
       â”‚  - inconsistent_states     (ä¸ä¸€è‡´çŠ¶æ€è¿½è¸ª) ğŸ†•       â”‚
       â”‚                                                      â”‚
       â”‚  æ•°æ®æµ:                                              â”‚
       â”‚  1. å¼€ä»“: AI â†’ äº¤æ˜“æ‰€ â†’ æ•°æ®åº“                       â”‚
       â”‚  2. æ¡ä»¶å•è§¦å‘: äº¤æ˜“æ‰€(è‡ªåŠ¨) â†’ ç›‘æ§æœåŠ¡ â†’ æ•°æ®åº“      â”‚
       â”‚  3. AIä¸»åŠ¨å¹³ä»“: AI â†’ äº¤æ˜“æ‰€ â†’ æ•°æ®åº“                â”‚
       â”‚  4. çŠ¶æ€åŒæ­¥: äº¤æ˜“æ‰€ â† æ•°æ®åº“ (å‘¨æœŸæ€§æ ¡éªŒ)           â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ•°æ®ä¸€è‡´æ€§å…³é”®ç‚¹

| æ•°æ®é¡¹ | äº¤æ˜“æ‰€API | æ•°æ®åº“ | æƒå¨æ¥æº | ä¸€è‡´æ€§ç­–ç•¥ |
|-------|----------|--------|---------|-----------|
| æŒä»“çŠ¶æ€ | å®æ—¶å‡†ç¡® | å¯èƒ½å»¶è¿Ÿ | äº¤æ˜“æ‰€ | å‘¨æœŸæ€§åŒæ­¥ + äº‹åŠ¡ä¿æŠ¤ |
| æ¡ä»¶å•çŠ¶æ€ | å®æ—¶å‡†ç¡® | å¯èƒ½å»¶è¿Ÿ | äº¤æ˜“æ‰€ | äº‹ä»¶é©±åŠ¨æ›´æ–° + å¥åº·æ£€æŸ¥ |
| æˆäº¤è®°å½• | æƒå¨æ¥æº | é•œåƒå­˜å‚¨ | äº¤æ˜“æ‰€ | å•å‘åŒæ­¥ï¼Œä¸å¯ä¿®æ”¹ |
| ç›ˆäºè®¡ç®— | å®æ—¶æµ®ç›ˆ | å†å²è®°å½• | å¹³ä»“æ—¶å›ºåŒ– | å®é™…æˆäº¤ä»·æ ¼è®¡ç®— |

---

## æ ¸å¿ƒä¸šåŠ¡æµç¨‹

### 1. å¼€ä»“æµç¨‹ (openPositionTool)

```mermaid
sequenceDiagram
    participant AI as AI Agent
    participant Tool as openPositionTool
    participant Risk as é£æ§æ£€æŸ¥
    participant Exchange as äº¤æ˜“æ‰€API
    participant DB as æ•°æ®åº“
    
    AI->>Tool: è¯·æ±‚å¼€ä»“(symbol, side, leverage, amountUsdt)
    Tool->>Risk: 1. é£æ§æ£€æŸ¥
    Risk->>Risk: - æŒä»“æ•°é‡é™åˆ¶(æœ€å¤š5ä¸ª)
    Risk->>Risk: - ç¦æ­¢åŒå‘æŒä»“
    Risk->>Risk: - ä¿è¯é‡‘å……è¶³æ€§
    Risk->>Risk: - æ€»æ•å£æ£€æŸ¥
    Risk->>Risk: - æµåŠ¨æ€§ä¿æŠ¤
    Risk->>Risk: - æ³¢åŠ¨ç‡è‡ªé€‚åº”
    Risk->>Tool: é£æ§é€šè¿‡
    
    Tool->>Risk: 2. ç§‘å­¦æ­¢æŸé¢„è®¡ç®—
    Risk->>Risk: è®¡ç®—æ­¢æŸä½
    Risk->>Risk: éªŒè¯æ­¢æŸè·ç¦»(minDistance~maxDistance)
    Risk->>Tool: æ­¢æŸéªŒè¯é€šè¿‡
    
    Tool->>Exchange: 3. è®¾ç½®æ æ†
    Exchange-->>Tool: æ æ†å·²è®¾ç½®
    
    Tool->>Exchange: 4. å¸‚ä»·å•å¼€ä»“(price=0)
    Exchange-->>Tool: è®¢å•å·²æˆäº¤(order_id, status)
    
    Tool->>Exchange: 5. æŸ¥è¯¢è®¢å•è¯¦æƒ…(é‡è¯•3æ¬¡)
    Exchange-->>Tool: å®é™…æˆäº¤ä»·ã€æˆäº¤æ•°é‡
    
    Tool->>DB: 6. è®°å½•å¼€ä»“äº¤æ˜“(tradesè¡¨)
    Tool->>Exchange: 7. è®¾ç½®ç§‘å­¦æ­¢æŸæ­¢ç›ˆ
    Exchange-->>Tool: æ¡ä»¶å•å·²åˆ›å»º(sl_order_id, tp_order_id)
    
    Tool->>DB: 8. ä¿å­˜æ¡ä»¶å•(price_ordersè¡¨)
    Tool->>DB: 9. è®°å½•æŒä»“(positionsè¡¨)
    
    Tool-->>AI: å¼€ä»“æˆåŠŸ
```

**å…³é”®ç‚¹**ï¼š

1. **å¼€ä»“å‰å¼ºåˆ¶éªŒè¯æ­¢æŸ**ï¼šæ‹’ç»æ­¢æŸè·ç¦»è¿‡è¿‘(<0.5%)æˆ–è¿‡è¿œ(>5%)çš„äº¤æ˜“
2. **æ»‘ç‚¹ä¿æŠ¤**ï¼šæˆäº¤ä»·åç¦»è¶…è¿‡2%è‡ªåŠ¨å›æ»šäº¤æ˜“
3. **å®é™…æˆäº¤ä»·è·å–**ï¼šç­‰å¾…2ç§’åæŸ¥è¯¢ï¼Œæœ€å¤šé‡è¯•3æ¬¡
4. **ç§‘å­¦æ­¢æŸæ­¢ç›ˆ**ï¼šå¼€ä»“åç«‹å³åœ¨äº¤æ˜“æ‰€è®¾ç½®æ¡ä»¶å•ï¼Œä¸ä¾èµ–æœ¬åœ°ç›‘æ§

### 2. AIä¸»åŠ¨å¹³ä»“æµç¨‹ (closePositionTool)

```mermaid
sequenceDiagram
    participant AI as AI Agent
    participant Tool as closePositionTool
    participant Exchange as äº¤æ˜“æ‰€API
    participant DB as æ•°æ®åº“
    
    AI->>Tool: è¯·æ±‚å¹³ä»“(symbol, percentage, reason)
    Tool->>Tool: 1. å‚æ•°éªŒè¯
    Tool->>Tool: 2. é˜²æ­¢åŒå‘¨æœŸå¹³ä»“(< åŠä¸ªäº¤æ˜“å‘¨æœŸæ‹’ç»)
    Tool->>Tool: 3. è®¡ç®—å¹³ä»“æ•°é‡(Gate.ioå‘ä¸Šå–æ•´)
    
    Tool->>Exchange: 4. å¸‚ä»·å•å¹³ä»“(reduceOnly=true)
    Exchange-->>Tool: å¹³ä»“æˆåŠŸ(order_id, fill_price)
    
    Tool->>Tool: 5. è®¡ç®—ç›ˆäº(grossPnl - totalFee)
    
    Tool->>Exchange: 6. å–æ¶ˆäº¤æ˜“æ‰€æ¡ä»¶å•
    Exchange-->>Tool: æ¡ä»¶å•å·²å–æ¶ˆ
    
    Note over Tool,DB: âš ï¸ ä»¥ä¸‹ä¸ºæ•°æ®åº“äº‹åŠ¡æ“ä½œ
    Tool->>DB: BEGIN TRANSACTION
    Tool->>DB: 7. DELETE FROM positions (â­ï¸æœ€å…ˆåˆ é™¤)
    Tool->>DB: 8. UPDATE price_orders (status='cancelled')
    Tool->>DB: 9. INSERT INTO trades (type='close')
    Tool->>DB: 10. INSERT INTO position_close_events
    Tool->>DB: COMMIT
    
    Tool-->>AI: å¹³ä»“æˆåŠŸ
```

**å½“å‰é—®é¢˜**ï¼š

- âŒ æ­¥éª¤7-10æ²¡æœ‰äº‹åŠ¡ä¿æŠ¤
- âŒ æŒä»“è®°å½•ï¼ˆæ­¥éª¤7ï¼‰åœ¨æœ€åæ‰åˆ é™¤
- âŒ å¦‚æœæ­¥éª¤6-10ä»»ä½•ä¸€æ­¥å¤±è´¥ï¼Œæ•°æ®ä¸ä¸€è‡´

**æ”¹è¿›æ–¹æ¡ˆ**ï¼š

1. äº¤æ˜“æ‰€æ“ä½œï¼ˆæ­¥éª¤4-6ï¼‰ä¸æ•°æ®åº“æ“ä½œï¼ˆæ­¥éª¤7-10ï¼‰åˆ†ç¦»
2. æ•°æ®åº“æ“ä½œä½¿ç”¨äº‹åŠ¡åŒ…è£¹
3. æŒä»“è®°å½•åœ¨äº‹åŠ¡ä¸­æœ€å…ˆåˆ é™¤
4. äº¤æ˜“æ‰€æ“ä½œå¤±è´¥ç›´æ¥è¿”å›ï¼Œæ•°æ®åº“æ“ä½œå¤±è´¥è®°å½•å¼‚å¸¸çŠ¶æ€

### 3. æ¡ä»¶å•è§¦å‘å¹³ä»“æµç¨‹ (priceOrderMonitor)

```mermaid
sequenceDiagram
    participant Monitor as æ¡ä»¶å•ç›‘æ§(30ç§’å‘¨æœŸ)
    participant Exchange as äº¤æ˜“æ‰€API
    participant DB as æ•°æ®åº“
    
    Note over Monitor: å®šæ—¶æ£€æµ‹(æ¯30ç§’)
    
    Monitor->>DB: 1. æŸ¥è¯¢activeæ¡ä»¶å•
    DB-->>Monitor: active_orders[]
    
    Monitor->>Exchange: 2. æŸ¥è¯¢äº¤æ˜“æ‰€æ¡ä»¶å•åˆ—è¡¨
    Exchange-->>Monitor: exchange_orders[]
    
    Monitor->>Exchange: 3. æŸ¥è¯¢äº¤æ˜“æ‰€æŒä»“åˆ—è¡¨
    Exchange-->>Monitor: exchange_positions[]
    
    Monitor->>Monitor: 4. è¯†åˆ«è§¦å‘çš„æ¡ä»¶å•
    Note over Monitor: åˆ¤æ–­é€»è¾‘:<br/>- è®¢å•ä¸åœ¨äº¤æ˜“æ‰€ + æŒä»“ä¸å­˜åœ¨ â†’ ç¡®å®šè§¦å‘<br/>- è®¢å•ä¸åœ¨äº¤æ˜“æ‰€ + æŒä»“å­˜åœ¨ â†’ æ£€æŸ¥æˆäº¤è®°å½•
    
    Monitor->>Exchange: 5. æŸ¥è¯¢æˆäº¤è®°å½•(getMyTrades, limit=500)
    Exchange-->>Monitor: trades[]
    
    alt æ‰¾åˆ°å¹³ä»“äº¤æ˜“
        Monitor->>DB: 6. æŸ¥è¯¢æŒä»“ä¿¡æ¯(positionsè¡¨)
        alt æŒä»“å­˜åœ¨
            DB-->>Monitor: position_info
        else æŒä»“ä¸å­˜åœ¨
            Monitor->>DB: ä»tradesè¡¨æŸ¥æ‰¾å¼€ä»“è®°å½•
            DB-->>Monitor: open_trade_info
        end
        
        Monitor->>Monitor: 7. è®¡ç®—ç›ˆäº
        
        Note over Monitor,DB: âš ï¸ æ•°æ®åº“äº‹åŠ¡æ“ä½œ
        Monitor->>DB: BEGIN TRANSACTION
        Monitor->>DB: 8. DELETE FROM positions (â­ï¸æœ€å…ˆåˆ é™¤)
        Monitor->>DB: 9. UPDATE price_orders (status='triggered')
        Monitor->>DB: 10. å–æ¶ˆåå‘æ¡ä»¶å•(status='cancelled')
        Monitor->>DB: 11. INSERT INTO trades (type='close')
        Monitor->>DB: 12. INSERT INTO position_close_events
        Monitor->>DB: COMMIT
        
    else æœªæ‰¾åˆ°å¹³ä»“äº¤æ˜“
        Monitor->>DB: BEGIN TRANSACTION
        Monitor->>DB: UPDATE price_orders (status='cancelled')
        Monitor->>DB: å–æ¶ˆåå‘æ¡ä»¶å•
        Monitor->>Exchange: æ£€æŸ¥æŒä»“æ˜¯å¦å­˜åœ¨
        alt æŒä»“ä¸å­˜åœ¨
            Monitor->>DB: DELETE FROM positions
        end
        Monitor->>DB: COMMIT
    end
```

**å½“å‰é—®é¢˜**ï¼š

- âŒ æ­¥éª¤8-12æ²¡æœ‰äº‹åŠ¡ä¿æŠ¤
- âŒ å¦‚æœæ­¥éª¤11å¤±è´¥ï¼Œæ•°æ®åº“æœ‰æŒä»“ä½†æ— å¹³ä»“è®°å½•
- âŒ å¦‚æœæˆäº¤è®°å½•æŸ¥è¯¢å¤±è´¥ï¼Œå¯èƒ½é—æ¼å¹³ä»“äº‹ä»¶

**å·²å®æ–½çš„ä¿®å¤**ï¼š

- âœ… æ‰©å±•æˆäº¤è®°å½•æŸ¥è¯¢åˆ°500ç¬”ã€24å°æ—¶çª—å£
- âœ… ç§»é™¤è™šå‡å¹³ä»“è®°å½•åˆ›å»ºé€»è¾‘
- âœ… å¢åŠ å¹¶å‘ä¿æŠ¤ï¼ˆisRunningæ ‡å¿—ï¼‰

**å¾…æ”¹è¿›**ï¼š

- â³ æ­¥éª¤8-12ä½¿ç”¨äº‹åŠ¡åŒ…è£¹
- â³ æŒä»“è®°å½•åœ¨äº‹åŠ¡ä¸­æœ€å…ˆåˆ é™¤
- â³ å¤±è´¥æ—¶è®°å½•å¼‚å¸¸çŠ¶æ€

---

## äº‹åŠ¡ä¿æŠ¤æ–¹æ¡ˆ

### æ–¹æ¡ˆè®¾è®¡åŸåˆ™

1. **äº¤æ˜“æ‰€æ“ä½œä¸æ•°æ®åº“æ“ä½œåˆ†ç¦»**ï¼šäº¤æ˜“æ‰€APIè°ƒç”¨ä¸å¯å›æ»šï¼Œå¿…é¡»å…ˆå®Œæˆ
2. **è¡¥å¿äº‹åŠ¡æ¨¡å¼ (Saga Pattern)**ï¼šäº¤æ˜“æ‰€æ“ä½œå¤±è´¥ç›´æ¥è¿”å›ï¼ŒæˆåŠŸåå†æ‰§è¡Œæ•°æ®åº“äº‹åŠ¡
3. **æ“ä½œé¡ºåºä¼˜åŒ–**ï¼šå…³é”®æ“ä½œï¼ˆåˆ é™¤æŒä»“ï¼‰æ”¾åœ¨äº‹åŠ¡æœ€å‰é¢
4. **å¼‚å¸¸çŠ¶æ€è®°å½•**ï¼šäº¤æ˜“æ‰€æˆåŠŸä½†æ•°æ®åº“å¤±è´¥æ—¶ï¼Œè®°å½•åˆ°ä¸“é—¨çš„è¡¨ä¾›äººå·¥å¤„ç†
5. **å¹‚ç­‰æ€§ä¿è¯**ï¼šæ”¯æŒé‡å¤æ‰§è¡Œä¸äº§ç”Ÿå‰¯ä½œç”¨

### æ–¹æ¡ˆ1: æ ‡å‡†äº‹åŠ¡ + æ“ä½œé¡ºåºä¼˜åŒ– (æ¨è)

#### 1.1 ä¿®æ”¹ closePositionTool å®Œæ•´å®ç°

```typescript
// æ–‡ä»¶: src/tools/trading/tradeExecution.ts

export const closePositionTool = createTool({
  name: "closePosition",
  description: `å¹³ä»“ - å¹³æ‰æŒ‡å®šå¸ç§çš„æŒä»“ï¼ˆæ”¯æŒéƒ¨åˆ†å¹³ä»“ï¼‰`,
  parameters: z.object({
    symbol: z.enum(RISK_PARAMS.TRADING_SYMBOLS).describe("å¸ç§ä»£ç "),
    percentage: z.number().min(1).max(100).describe("å¹³ä»“æ¯”ä¾‹ (1-100)"),
    reason: z.string().optional().describe("å¹³ä»“åŸå› "),
  }),
  execute: async ({ symbol, percentage, reason = 'manual_close' }) => {
    const exchangeClient = getExchangeClient();
    const contract = exchangeClient.normalizeContract(symbol);
    const timestamp = getChinaTimeISO();
    
    try {
      // ========== é˜¶æ®µ0: å‚æ•°éªŒè¯å’ŒæŒä»“æ£€æŸ¥ ==========
      logger.info(`ğŸ”„ é˜¶æ®µ0: å‚æ•°éªŒè¯...`);
      
      // æŸ¥è¯¢æŒä»“
      const positions = await exchangeClient.getPositions();
      const position = positions.find((p: any) => {
        const posSymbol = exchangeClient.extractSymbol(p.contract);
        return posSymbol === symbol && Math.abs(parsePositionSize(p.size)) > 0;
      });
      
      if (!position) {
        return {
          success: false,
          message: `${symbol} æ²¡æœ‰æŒä»“ï¼Œæ— æ³•å¹³ä»“`,
        };
      }
      
      const positionSize = parsePositionSize(position.size);
      const side = positionSize > 0 ? "long" : "short";
      const entryPrice = Number.parseFloat(position.entryPrice || "0");
      const leverage = Number.parseInt(position.leverage || "1");
      
      // é˜²æ­¢åŒå‘¨æœŸå¹³ä»“ä¿æŠ¤
      const dbPositionResult = await dbClient.execute({
        sql: 'SELECT opened_at FROM positions WHERE symbol = ? AND side = ?',
        args: [symbol, side]
      });
      
      if (dbPositionResult.rows.length > 0) {
        const openedAt = dbPositionResult.rows[0].opened_at as string;
        const openTime = new Date(openedAt).getTime();
        const nowTime = Date.now();
        const holdingTimeMinutes = (nowTime - openTime) / (1000 * 60);
        const minHoldingMinutes = (RISK_PARAMS.LOOP_INTERVAL_SECONDS / 60) * 0.5;
        
        if (holdingTimeMinutes < minHoldingMinutes) {
          return {
            success: false,
            message: `${symbol} æŒä»“æ—¶é—´è¿‡çŸ­ (${holdingTimeMinutes.toFixed(1)}åˆ†é’Ÿ < ${minHoldingMinutes}åˆ†é’Ÿ)ï¼Œé˜²æ­¢åŒå‘¨æœŸå¹³ä»“`,
          };
        }
      }
      
      // è®¡ç®—å¹³ä»“æ•°é‡
      let closeSize: number;
      if (percentage === 100) {
        closeSize = Math.abs(positionSize);
      } else {
        closeSize = Math.abs(positionSize) * (percentage / 100);
      }
      
      // Gate.io åå‘åˆçº¦ï¼šå‘ä¸Šå–æ•´åˆ°æœ€å°å¼ æ•°
      const contractType = exchangeClient.getContractType();
      if (contractType === 'inverse') {
        closeSize = Math.ceil(closeSize);
      } else {
        // Binance æ­£å‘åˆçº¦ï¼šç²¾åº¦å¤„ç†
        closeSize = adjustQuantityPrecision(closeSize, symbol);
      }
      
      // éªŒè¯æœ€å°äº¤æ˜“æ•°é‡
      const contractInfo = await exchangeClient.getContractInfo(contract);
      const minSize = contractInfo.orderSizeMin || 1;
      
      if (closeSize < minSize) {
        return {
          success: false,
          message: `å¹³ä»“æ•°é‡ ${closeSize} å°äºæœ€å°é™åˆ¶ ${minSize}`,
        };
      }
      
      const size = side === "long" ? -closeSize : closeSize;
      const unit = contractType === 'inverse' ? 'å¼ ' : symbol;
      
      logger.info(`âœ… å‚æ•°éªŒè¯é€šè¿‡: ${symbol} ${side} ${closeSize}${unit} (${percentage}%)`);
      
      // ========== é˜¶æ®µ1: äº¤æ˜“æ‰€æ“ä½œ (ä¸å¯å›æ»šéƒ¨åˆ†) ==========
      logger.info('ğŸ”„ é˜¶æ®µ1: æ‰§è¡Œäº¤æ˜“æ‰€æ“ä½œ...');
      
      let order: any;
      let actualExitPrice: number;
      let actualCloseSize: number;
      let finalOrderStatus: string;
      let orderFillTime: string;
      
      try {
        // 1.1 å¸‚ä»·å•å¹³ä»“
        logger.debug(`å‘é€å¹³ä»“è®¢å•: size=${size}, reduceOnly=true`);
        order = await exchangeClient.placeOrder({
          contract,
          size,
          price: 0,
          reduceOnly: true,
        });
        
        logger.info(`ğŸ“¨ å¹³ä»“è®¢å•å·²æäº¤: order_id=${order.id}`);
        
        // 1.2 ç­‰å¾…å¹¶è·å–å®é™…æˆäº¤ä¿¡æ¯ï¼ˆé‡è¯•æœºåˆ¶ï¼‰
        await new Promise(resolve => setTimeout(resolve, 500));
        
        let retryCount = 0;
        const maxRetries = 3;
        let orderDetailSuccess = false;
        
        while (retryCount < maxRetries && !orderDetailSuccess) {
          try {
            const orderDetail = await exchangeClient.getOrder(order.id.toString());
            
            // è§£ææˆäº¤æ•°é‡
            const totalSize = Math.abs(Number.parseFloat(orderDetail.size || "0"));
            const leftSize = Math.abs(Number.parseFloat(orderDetail.left || "0"));
            actualCloseSize = totalSize - leftSize;
            
            // è§£ææˆäº¤ä»·æ ¼
            if (orderDetail.fill_price && Number.parseFloat(orderDetail.fill_price) > 0) {
              actualExitPrice = Number.parseFloat(orderDetail.fill_price);
            } else if (orderDetail.price && Number.parseFloat(orderDetail.price) > 0) {
              actualExitPrice = Number.parseFloat(orderDetail.price);
            } else {
              // å¦‚æœè®¢å•è¯¦æƒ…æ²¡æœ‰ä»·æ ¼ï¼ŒæŸ¥è¯¢æˆäº¤è®°å½•
              logger.warn(`è®¢å•è¯¦æƒ…æ— æˆäº¤ä»·ï¼ŒæŸ¥è¯¢æˆäº¤è®°å½•...`);
              const trades = await exchangeClient.getMyTrades(contract, 10);
              const matchingTrade = trades.find((t: any) => 
                (t.order_id?.toString() === order.id?.toString()) ||
                (t.orderId?.toString() === order.id?.toString())
              );
              if (matchingTrade) {
                actualExitPrice = Number.parseFloat(matchingTrade.price || matchingTrade.avgPrice || "0");
              } else {
                throw new Error('æ— æ³•è·å–å®é™…æˆäº¤ä»·æ ¼');
              }
            }
            
            finalOrderStatus = orderDetail.status;
            
            // æˆäº¤æ—¶é—´ï¼ˆä¼˜å…ˆä½¿ç”¨è®¢å•è¯¦æƒ…ï¼Œå¦åˆ™ä½¿ç”¨å½“å‰æ—¶é—´ï¼‰
            if (orderDetail.finish_time) {
              orderFillTime = new Date(orderDetail.finish_time * 1000).toISOString();
            } else if (orderDetail.create_time) {
              orderFillTime = new Date(orderDetail.create_time * 1000).toISOString();
            } else {
              orderFillTime = timestamp;
            }
            
            logger.info(`âœ… å¹³ä»“æˆäº¤: ${actualCloseSize}${unit} @ ${actualExitPrice.toFixed(2)} USDT`);
            orderDetailSuccess = true;
            
          } catch (error: any) {
            retryCount++;
            if (retryCount >= maxRetries) {
              logger.error(`è·å–è®¢å•è¯¦æƒ…å¤±è´¥ï¼ˆé‡è¯•${retryCount}æ¬¡ï¼‰: ${error.message}`);
              // ä½¿ç”¨é¢„ä¼°å€¼ç»§ç»­
              actualCloseSize = closeSize;
              const ticker = await exchangeClient.getFuturesTicker(contract);
              actualExitPrice = Number.parseFloat(ticker.last || "0");
              finalOrderStatus = 'unknown';
              orderFillTime = timestamp;
              logger.warn(`âš ï¸ ä½¿ç”¨é¢„ä¼°å€¼: æ•°é‡=${actualCloseSize}, ä»·æ ¼=${actualExitPrice}`);
            } else {
              logger.warn(`è·å–è®¢å•è¯¦æƒ…å¤±è´¥ï¼Œ${retryCount}/${maxRetries} æ¬¡é‡è¯•...`);
              await new Promise(resolve => setTimeout(resolve, 300));
            }
          }
        }
        
      } catch (exchangeError: any) {
        logger.error('âŒ äº¤æ˜“æ‰€å¹³ä»“å¤±è´¥:', exchangeError);
        return {
          success: false,
          message: `å¹³ä»“å¤±è´¥: ${exchangeError.message}`,
          error: exchangeError.message,
        };
      }
      
      // 1.3 è®¡ç®—ç›ˆäº
      logger.debug(`è®¡ç®—ç›ˆäº: entry=${entryPrice}, exit=${actualExitPrice}, size=${actualCloseSize}`);
      
      const grossPnl = await exchangeClient.calculatePnl(
        entryPrice, actualExitPrice, actualCloseSize, side, contract
      );
      
      // è®¡ç®—æ‰‹ç»­è´¹ï¼ˆå¼€ä»“ + å¹³ä»“ï¼‰
      let positionValue: number;
      if (contractType === 'inverse') {
        const quantoMultiplier = await getQuantoMultiplier(contract);
        positionValue = actualCloseSize * quantoMultiplier * actualExitPrice;
      } else {
        positionValue = actualCloseSize * actualExitPrice;
      }
      
      const openFee = positionValue * 0.0005; // 0.05% takerè´¹ç‡
      const closeFee = positionValue * 0.0005;
      const totalFee = openFee + closeFee;
      const netPnl = grossPnl - totalFee;
      
      // è®¡ç®—ç›ˆäºç™¾åˆ†æ¯”ï¼ˆå«æ æ†ï¼‰
      const priceChangePercent = side === "long"
        ? ((actualExitPrice - entryPrice) / entryPrice) * 100
        : ((entryPrice - actualExitPrice) / entryPrice) * 100;
      const pnlPercent = priceChangePercent * leverage;
      
      logger.info(`ğŸ’° ç›ˆäº: æ¯›åˆ©=${grossPnl.toFixed(2)} USDT, æ‰‹ç»­è´¹=${totalFee.toFixed(2)} USDT, å‡€åˆ©=${netPnl.toFixed(2)} USDT (${pnlPercent.toFixed(2)}%)`);
      
      // 1.4 å–æ¶ˆäº¤æ˜“æ‰€æ¡ä»¶å•ï¼ˆåªåœ¨100%å¹³ä»“æ—¶ï¼‰
      let cancelSuccess = false;
      if (percentage === 100) {
        try {
          logger.debug(`å–æ¶ˆäº¤æ˜“æ‰€æ¡ä»¶å•: ${contract}`);
          const cancelResult = await exchangeClient.cancelPositionStopLoss(contract);
          cancelSuccess = cancelResult.success;
          logger.info(cancelSuccess ? 'âœ… æ¡ä»¶å•å·²å–æ¶ˆ' : 'âš ï¸ æ¡ä»¶å•å–æ¶ˆå¤±è´¥');
        } catch (cancelError: any) {
          logger.warn('âš ï¸ å–æ¶ˆæ¡ä»¶å•å¼‚å¸¸:', cancelError.message);
        }
      }
      
      // ========== é˜¶æ®µ2: æ•°æ®åº“äº‹åŠ¡æ“ä½œ ==========
      logger.info('ğŸ”„ é˜¶æ®µ2: æ‰§è¡Œæ•°æ®åº“äº‹åŠ¡...');
      
      // å¼€å¯äº‹åŠ¡
      await dbClient.execute('BEGIN TRANSACTION');
      
      try {
        // â­ï¸ 2.1 æœ€å…³é”®: å…ˆåˆ é™¤æŒä»“è®°å½•ï¼ˆ100%å¹³ä»“æ—¶ï¼‰
        // å³ä½¿åç»­æ­¥éª¤å¤±è´¥ï¼Œä¹Ÿä¸ä¼šè¯¯è®¤ä¸ºæŒä»“å­˜åœ¨
        if (percentage === 100) {
          await dbClient.execute({
            sql: 'DELETE FROM positions WHERE symbol = ? AND side = ?',
            args: [symbol, side]
          });
          logger.debug('âœ… [äº‹åŠ¡] æ­¥éª¤1: æŒä»“è®°å½•å·²åˆ é™¤');
        } else {
          // éƒ¨åˆ†å¹³ä»“ï¼šæ›´æ–°æŒä»“æ•°é‡
          const newQuantity = Math.abs(positionSize) - actualCloseSize;
          await dbClient.execute({
            sql: 'UPDATE positions SET quantity = ? WHERE symbol = ? AND side = ?',
            args: [newQuantity, symbol, side]
          });
          logger.debug(`âœ… [äº‹åŠ¡] æ­¥éª¤1: æŒä»“æ•°é‡å·²æ›´æ–° ${Math.abs(positionSize)} â†’ ${newQuantity}`);
        }
        
        // â­ï¸ 2.2 ç¬¬äºŒå…³é”®: æ›´æ–°æ¡ä»¶å•çŠ¶æ€ï¼ˆ100%å¹³ä»“æ—¶ï¼‰
        // é˜²æ­¢æ¡ä»¶å•ç›‘æ§æœåŠ¡è¯¯åˆ¤ä¸ºè§¦å‘
        if (percentage === 100) {
          await dbClient.execute({
            sql: `UPDATE price_orders 
                  SET status = 'cancelled', updated_at = ?
                  WHERE symbol = ? AND side = ? AND status = 'active'`,
            args: [timestamp, symbol, side]
          });
          logger.debug('âœ… [äº‹åŠ¡] æ­¥éª¤2: æ¡ä»¶å•çŠ¶æ€å·²æ›´æ–°');
        }
        
        // 2.3 æ’å…¥å¹³ä»“äº¤æ˜“è®°å½•
        await dbClient.execute({
          sql: `INSERT INTO trades 
                (order_id, symbol, side, type, price, quantity, leverage, 
                 pnl, fee, timestamp, status)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          args: [
            order.id?.toString() || '',
            symbol, side, 'close',
            actualExitPrice, actualCloseSize, leverage,
            netPnl, totalFee, orderFillTime,
            finalOrderStatus === 'finished' ? 'filled' : 'pending'
          ]
        });
        logger.debug('âœ… [äº‹åŠ¡] æ­¥éª¤3: äº¤æ˜“è®°å½•å·²æ’å…¥');
        
        // 2.4 æ’å…¥å¹³ä»“äº‹ä»¶ (ä¾›AIå†³ç­–å‚è€ƒ)
        await dbClient.execute({
          sql: `INSERT INTO position_close_events 
                (symbol, side, entry_price, close_price, quantity, leverage,
                 pnl, pnl_percent, fee, close_reason, trigger_type, order_id,
                 created_at, processed)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          args: [
            symbol, side, entryPrice, actualExitPrice, actualCloseSize, leverage,
            netPnl, pnlPercent, totalFee, reason, 'ai_decision',
            order.id?.toString() || '', timestamp, 1
          ]
        });
        logger.debug('âœ… [äº‹åŠ¡] æ­¥éª¤4: å¹³ä»“äº‹ä»¶å·²è®°å½•');
        
        // æäº¤äº‹åŠ¡
        await dbClient.execute('COMMIT');
        logger.info('âœ… [äº‹åŠ¡] æ‰€æœ‰æ•°æ®åº“æ“ä½œå·²æäº¤');
        
        // è¿”å›æˆåŠŸ
        return {
          success: true,
          orderId: order.id?.toString(),
          symbol,
          side,
          percentage,
          closedSize: actualCloseSize,
          entryPrice,
          exitPrice: actualExitPrice,
          pnl: netPnl,
          pnlPercent,
          fee: totalFee,
          message: `æˆåŠŸå¹³ä»“ ${symbol} ${actualCloseSize}${unit} (${percentage}%)ï¼Œå‡€ç›ˆäº ${netPnl >= 0 ? '+' : ''}${netPnl.toFixed(2)} USDT (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)`,
        };
        
      } catch (dbError: any) {
        // å›æ»šäº‹åŠ¡
        await dbClient.execute('ROLLBACK');
        logger.error('âŒ [äº‹åŠ¡] æ•°æ®åº“æ“ä½œå¤±è´¥ï¼Œå·²å›æ»š:', dbError);
        
        // âš ï¸ å…³é”®: è®°å½•ä¸ä¸€è‡´çŠ¶æ€
        // äº¤æ˜“æ‰€æ“ä½œå·²å®Œæˆï¼Œä½†æ•°æ®åº“è®°å½•å¤±è´¥
        await recordInconsistentState({
          operation: 'close_position',
          symbol,
          side,
          exchangeSuccess: true,
          dbSuccess: false,
          exchangeOrderId: order.id?.toString(),
          errorMessage: dbError.message,
          timestamp,
        });
        
        return {
          success: false,
          partialSuccess: true,  // äº¤æ˜“æ‰€æ“ä½œæˆåŠŸ
          needsManualCheck: true,
          message: 'å¹³ä»“æˆåŠŸä½†æ•°æ®è®°å½•å¤±è´¥ï¼Œéœ€è¦äººå·¥æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§',
          orderId: order.id?.toString(),
          error: dbError.message,
        };
      }
      
    } catch (error: any) {
      logger.error('å¹³ä»“å¤±è´¥:', error);
      return {
        success: false,
        error: error.message,
        message: `å¹³ä»“å¤±è´¥: ${error.message}`,
      };
    }
  },
});

// è¾…åŠ©å‡½æ•°: è®°å½•ä¸ä¸€è‡´çŠ¶æ€
async function recordInconsistentState(data: {
  operation: string;
  symbol: string;
  side: string;
  exchangeSuccess: boolean;
  dbSuccess: boolean;
  exchangeOrderId?: string;
  errorMessage: string;
  timestamp: string;
}) {
  try {
    await dbClient.execute({
      sql: `INSERT INTO inconsistent_states 
            (operation, symbol, side, exchange_success, db_success, 
             exchange_order_id, error_message, created_at, resolved)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [
        data.operation,
        data.symbol,
        data.side,
        data.exchangeSuccess ? 1 : 0,
        data.dbSuccess ? 1 : 0,
        data.exchangeOrderId || null,
        data.errorMessage,
        data.timestamp,
        0  // æœªè§£å†³
      ]
    });
    logger.warn('âš ï¸ å·²è®°å½•ä¸ä¸€è‡´çŠ¶æ€åˆ°æ•°æ®åº“');
  } catch (recordError: any) {
    logger.error('âŒ è®°å½•ä¸ä¸€è‡´çŠ¶æ€å¤±è´¥:', recordError);
    // è®°å½•åˆ°æ–‡ä»¶ä½œä¸ºå¤‡ä»½
    const fs = require('fs');
    const logPath = './logs/inconsistent_states.log';
    fs.appendFileSync(logPath, JSON.stringify(data) + '\n');
  }
}
```

#### 1.2 ä¿®æ”¹ priceOrderMonitor å®Œæ•´å®ç°

```typescript
// æ–‡ä»¶: src/scheduler/priceOrderMonitor.ts

/**
 * å¤„ç†å·²è§¦å‘çš„æ¡ä»¶å•
 */
private async handleTriggeredOrder(order: DBPriceOrder) {
  logger.debug(`ğŸ” æ£€æŸ¥æ¡ä»¶å•: ${order.symbol} ${order.type} ${order.order_id}`);

  // é˜¶æ®µ1: æŸ¥è¯¢æŒä»“ä¿¡æ¯ (ç”¨äºè®¡ç®—PnL)
  let position = await this.getPositionInfo(order.symbol, order.side);
  
  // å¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰æŒä»“è®°å½•ï¼Œå°è¯•ä»å¼€ä»“äº¤æ˜“è®°å½•ä¸­æŸ¥æ‰¾
  if (!position) {
    logger.warn(`æ•°æ®åº“ä¸­æœªæ‰¾åˆ° ${order.symbol} ${order.side} çš„æŒä»“ä¿¡æ¯ï¼Œå°è¯•ä»äº¤æ˜“è®°å½•æŸ¥æ‰¾...`);
    const openTrade = await this.findOpenTrade(order.symbol, order.side);
    if (openTrade) {
      // ä½¿ç”¨å¼€ä»“äº¤æ˜“ä¿¡æ¯æ„å»ºæŒä»“å¯¹è±¡
      position = {
        symbol: openTrade.symbol,
        side: openTrade.side,
        entry_price: openTrade.price,
        quantity: openTrade.quantity,
        leverage: openTrade.leverage,
      };
      logger.info(`âœ… ä»äº¤æ˜“è®°å½•æ¢å¤æŒä»“ä¿¡æ¯: ${order.symbol} @ ${position.entry_price}`);
    }
  }
  
  // é˜¶æ®µ2: æŸ¥æ‰¾å¹³ä»“äº¤æ˜“ï¼ˆä»äº¤æ˜“æ‰€æŸ¥è¯¢å®é™…çš„æˆäº¤è®°å½•ï¼‰
  const closeTrade = await this.findCloseTrade(order);
  
  // âš ï¸ å…³é”®ä¿®å¤ï¼šå¦‚æœäº¤æ˜“æ‰€æ²¡æœ‰å¹³ä»“è®°å½•ï¼Œè¯´æ˜æ¡ä»¶å•å¹¶æœªçœŸæ­£è§¦å‘
  //    å¯èƒ½çš„åŸå› ï¼š
  //    a) æ¡ä»¶å•è¢«æ‰‹åŠ¨å–æ¶ˆ
  //    b) æŒä»“å·²é€šè¿‡å…¶ä»–æ–¹å¼å¹³ä»“ï¼ˆæ‰‹åŠ¨å¹³ä»“ã€å…¶ä»–æ¡ä»¶å•è§¦å‘ï¼‰
  //    c) ç³»ç»Ÿå¼‚å¸¸å¯¼è‡´çŠ¶æ€ä¸ä¸€è‡´
  //    
  //    æ­£ç¡®çš„å¤„ç†æ–¹å¼ï¼šæ ‡è®°ä¸ºcancelledï¼Œä¸åˆ›å»ºè™šå‡çš„å¹³ä»“è®°å½•
  if (!closeTrade) {
    logger.warn(`âš ï¸ æœªæ‰¾åˆ° ${order.symbol} çš„å¹³ä»“äº¤æ˜“è®°å½•ï¼Œæ¡ä»¶å•å¯èƒ½è¢«å–æ¶ˆæˆ–æŒä»“å·²é€šè¿‡å…¶ä»–æ–¹å¼å¹³ä»“`);
    
    // å¼€å¯äº‹åŠ¡å¤„ç†çŠ¶æ€æ›´æ–°
    await this.dbClient.execute('BEGIN TRANSACTION');
    
    try {
      // åªæ›´æ–°æ¡ä»¶å•çŠ¶æ€ä¸ºcancelled
      await this.updateOrderStatus(order.order_id, 'cancelled');
      logger.debug('âœ… [äº‹åŠ¡] æ­¥éª¤1: æ¡ä»¶å•çŠ¶æ€å·²æ›´æ–°ä¸ºcancelled');
      
      // å–æ¶ˆåå‘æ¡ä»¶å•
      await this.cancelOppositeOrderInDB(order);
      logger.debug('âœ… [äº‹åŠ¡] æ­¥éª¤2: åå‘æ¡ä»¶å•å·²å–æ¶ˆ');
      
      // æ£€æŸ¥æŒä»“æ˜¯å¦è¿˜å­˜åœ¨
      const contract = this.exchangeClient.normalizeContract(order.symbol);
      const positions = await this.exchangeClient.getPositions();
      const positionExists = positions.some(p => 
        p.contract === contract && Math.abs(parseFloat(p.size || '0')) > 0
      );
      
      if (!positionExists) {
        // æŒä»“ç¡®å®ä¸å­˜åœ¨äº†ï¼Œä»æ•°æ®åº“ä¸­åˆ é™¤
        await this.dbClient.execute({
          sql: 'DELETE FROM positions WHERE symbol = ? AND side = ?',
          args: [order.symbol, order.side]
        });
        logger.debug('âœ… [äº‹åŠ¡] æ­¥éª¤3: æŒä»“è®°å½•å·²åˆ é™¤');
      } else {
        logger.info(`${order.symbol} æŒä»“ä»å­˜åœ¨ï¼Œä¿ç•™æ•°æ®åº“è®°å½•`);
      }
      
      // æäº¤äº‹åŠ¡
      await this.dbClient.execute('COMMIT');
      logger.info(`âœ… [äº‹åŠ¡] ${order.symbol} æ¡ä»¶å•çŠ¶æ€æ›´æ–°å®Œæˆ`);
      
    } catch (error: any) {
      // å›æ»šäº‹åŠ¡
      await this.dbClient.execute('ROLLBACK');
      logger.error('âŒ [äº‹åŠ¡] æ›´æ–°æ¡ä»¶å•çŠ¶æ€å¤±è´¥ï¼Œå·²å›æ»š:', error);
    }
    
    return;
  }
  
  // é˜¶æ®µ3: ç¡®è®¤æœ‰æŒä»“ä¿¡æ¯æ‰ç»§ç»­
  if (!position) {
    logger.error(`âŒ æ— æ³•è·å– ${order.symbol} ${order.side} çš„æŒä»“ä¿¡æ¯ï¼Œæ— æ³•è®°å½•å¹³ä»“äº‹ä»¶`);
    // å³ä½¿æ— æ³•è®°å½•è¯¦æƒ…ï¼Œä¹Ÿè¦æ›´æ–°æ¡ä»¶å•çŠ¶æ€
    await this.updateOrderStatus(order.order_id, 'triggered');
    await this.cancelOppositeOrderInDB(order);
    return;
  }
  
  // é˜¶æ®µ4: ç¡®è®¤æ˜¯çœŸå®å¹³ä»“ï¼Œè®¡ç®—ç›ˆäº
  logger.info(`ğŸ”” ç¡®è®¤æ¡ä»¶å•è§¦å‘: ${order.symbol} ${order.type}, å¹³ä»“ä»·æ ¼: ${closeTrade.price}`);
  
  const entryPrice = parseFloat(position.entry_price as string);
  const exitPrice = parseFloat(closeTrade.price);
  const quantity = Math.abs(parseFloat(closeTrade.size));
  const leverage = position.leverage || 1;
  
  logger.debug(`è®¡ç®—ç›ˆäº: entry=${entryPrice}, exit=${exitPrice}, quantity=${quantity}, leverage=${leverage}`);
  
  // ä½¿ç”¨äº¤æ˜“æ‰€çš„calculatePnlæ–¹æ³•
  const grossPnl = await this.exchangeClient.calculatePnl(
    entryPrice, exitPrice, quantity, order.side, 
    this.exchangeClient.normalizeContract(order.symbol)
  );
  
  // è®¡ç®—æ‰‹ç»­è´¹
  const contractType = this.exchangeClient.getContractType();
  let positionValue: number;
  
  if (contractType === 'inverse') {
    const contract = this.exchangeClient.normalizeContract(order.symbol);
    const quantoMultiplier = await getQuantoMultiplier(contract);
    positionValue = quantity * quantoMultiplier * exitPrice;
  } else {
    positionValue = quantity * exitPrice;
  }
  
  const openFee = positionValue * 0.0005;
  const closeFee = positionValue * 0.0005;
  const totalFee = openFee + closeFee;
  const netPnl = grossPnl - totalFee;
  
  // è®¡ç®—ç›ˆäºç™¾åˆ†æ¯”
  const priceChangePercent = order.side === "long"
    ? ((exitPrice - entryPrice) / entryPrice) * 100
    : ((entryPrice - exitPrice) / entryPrice) * 100;
  const pnlPercent = priceChangePercent * leverage;
  
  logger.info(`ğŸ’° ç›ˆäº: æ¯›åˆ©=${grossPnl.toFixed(2)} USDT, æ‰‹ç»­è´¹=${totalFee.toFixed(2)} USDT, å‡€åˆ©=${netPnl.toFixed(2)} USDT (${pnlPercent.toFixed(2)}%)`);
  
  // é˜¶æ®µ5: æ•°æ®åº“äº‹åŠ¡æ“ä½œ
  const timestamp = new Date().toISOString();
  
  await this.dbClient.execute('BEGIN TRANSACTION');
  
  try {
    // â­ï¸ 5.1 å…ˆåˆ é™¤æŒä»“è®°å½•
    // å³ä½¿åç»­æ­¥éª¤å¤±è´¥ï¼Œä¹Ÿä¸ä¼šè¯¯è®¤ä¸ºæŒä»“å­˜åœ¨
    await this.dbClient.execute({
      sql: 'DELETE FROM positions WHERE symbol = ? AND side = ?',
      args: [order.symbol, order.side]
    });
    logger.debug('âœ… [äº‹åŠ¡] æ­¥éª¤1: æŒä»“è®°å½•å·²åˆ é™¤');
    
    // â­ï¸ 5.2 æ›´æ–°è§¦å‘çš„æ¡ä»¶å•çŠ¶æ€
    await this.updateOrderStatus(order.order_id, 'triggered');
    logger.debug('âœ… [äº‹åŠ¡] æ­¥éª¤2: æ¡ä»¶å•çŠ¶æ€å·²æ›´æ–°ä¸ºtriggered');
    
    // 5.3 å–æ¶ˆåå‘æ¡ä»¶å•
    await this.cancelOppositeOrderInDB(order);
    logger.debug('âœ… [äº‹åŠ¡] æ­¥éª¤3: åå‘æ¡ä»¶å•å·²å–æ¶ˆ');
    
    // 5.4 è®°å½•å¹³ä»“äº¤æ˜“
    await this.dbClient.execute({
      sql: `INSERT INTO trades 
            (order_id, symbol, side, type, price, quantity, leverage, pnl, fee, timestamp, status)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [
        closeTrade.id,
        order.symbol,
        order.side,
        'close',
        exitPrice,
        quantity,
        leverage,
        netPnl,
        totalFee,
        timestamp,
        'filled'
      ]
    });
    logger.debug('âœ… [äº‹åŠ¡] æ­¥éª¤4: äº¤æ˜“è®°å½•å·²æ’å…¥');
    
    // 5.5 è®°å½•å¹³ä»“äº‹ä»¶
    const closeReason = order.type === 'stop_loss' 
      ? 'stop_loss_triggered' 
      : 'take_profit_triggered';
    
    await this.dbClient.execute({
      sql: `INSERT INTO position_close_events 
            (symbol, side, close_reason, trigger_type, trigger_price, close_price, 
             entry_price, quantity, leverage, pnl, pnl_percent, fee, 
             trigger_order_id, close_trade_id, order_id, created_at, processed)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [
        order.symbol, order.side, closeReason, 'exchange_order',
        parseFloat(order.trigger_price), exitPrice, entryPrice,
        quantity, leverage, netPnl, pnlPercent, totalFee,
        order.order_id, closeTrade.id, order.order_id, timestamp, 0
      ]
    });
    logger.debug('âœ… [äº‹åŠ¡] æ­¥éª¤5: å¹³ä»“äº‹ä»¶å·²è®°å½•');
    
    // æäº¤äº‹åŠ¡
    await this.dbClient.execute('COMMIT');
    logger.info(`âœ… [äº‹åŠ¡] ${order.symbol} ${order.type} è§¦å‘å¤„ç†å®Œæˆ`);
    
  } catch (error: any) {
    // å›æ»šäº‹åŠ¡
    await this.dbClient.execute('ROLLBACK');
    logger.error('âŒ [äº‹åŠ¡] æ¡ä»¶å•è§¦å‘å¤„ç†å¤±è´¥ï¼Œå·²å›æ»š:', error);
    
    // âš ï¸ è®°å½•ä¸ä¸€è‡´çŠ¶æ€
    await recordInconsistentState({
      operation: 'price_order_triggered',
      symbol: order.symbol,
      side: order.side,
      exchangeSuccess: true,  // äº¤æ˜“æ‰€å·²å¹³ä»“
      dbSuccess: false,       // æ•°æ®åº“è®°å½•å¤±è´¥
      exchangeOrderId: order.order_id,
      errorMessage: error.message,
      timestamp,
    });
  }
}

/**
 * æ•°æ®åº“å†…å–æ¶ˆåå‘æ¡ä»¶å• (ä¸è°ƒç”¨äº¤æ˜“æ‰€API)
 */
private async cancelOppositeOrderInDB(triggeredOrder: DBPriceOrder) {
  const oppositeType = triggeredOrder.type === 'stop_loss' ? 'take_profit' : 'stop_loss';
  
  const result = await this.dbClient.execute({
    sql: `SELECT order_id FROM price_orders 
          WHERE symbol = ? AND side = ? AND type = ? AND status = 'active'
          LIMIT 1`,
    args: [triggeredOrder.symbol, triggeredOrder.side, oppositeType]
  });
  
  if (result.rows.length > 0) {
    const oppositeOrderId = result.rows[0].order_id as string;
    await this.updateOrderStatus(oppositeOrderId, 'cancelled');
    logger.debug(`âœ… å·²å–æ¶ˆåå‘æ¡ä»¶å•: ${oppositeOrderId}`);
  }
}
```

---

## å¤šäº¤æ˜“æ‰€å…¼å®¹æ€§

### Gate.io vs Binance æ ¸å¿ƒå·®å¼‚

| ç»´åº¦ | Gate.io | Binance | å¤„ç†æ–¹æ¡ˆ |
|-----|---------|---------|---------|
| **åˆçº¦ç±»å‹** | åå‘åˆçº¦(inverse) | æ­£å‘åˆçº¦(linear) | `exchangeClient.getContractType()` |
| **æ•°é‡å•ä½** | å¼ (contracts) | å¸(coins) | æ—¥å¿—æ˜¾ç¤ºåŒºåˆ† |
| **æ•°é‡ç²¾åº¦** | å¿…é¡»æ•´æ•° | æ”¯æŒå°æ•° | Gateè‡ªåŠ¨å‘ä¸Šå–æ•´ |
| **åˆçº¦ä¹˜æ•°** | éœ€è¦quanto multiplier | ä¸éœ€è¦ | `getQuantoMultiplier()` |
| **ç›ˆäºè®¡ç®—** | åå‘ï¼š(1/entry - 1/exit) *size* multiplier | æ­£å‘ï¼š(exit - entry) * size | `calculatePnl()` |
| **æˆäº¤ä»·è·å–** | fill_price | avgPrice | ç»Ÿä¸€`formatTradeRecord()` |
| **æ¡ä»¶å•API** | /futures/usdt/price_orders | /fapi/v1/allOpenOrders | `getPriceOrders()` |
| **å–æ¶ˆæ¡ä»¶å•** | DELETE /price_orders/{order_id} | DELETE /fapi/v1/allOpenOrders | `cancelPositionStopLoss()` |

### æ•°é‡è®¡ç®—å…¼å®¹æ€§å¤„ç†

```typescript
// Gate.io åå‘åˆçº¦æ•°é‡è®¡ç®—
if (contractType === 'inverse') {
  // å¼ æ•° = (ä¿è¯é‡‘ * æ æ†) / (quantoMultiplier * ä»·æ ¼)
  const quantoMultiplier = await getQuantoMultiplier(contract);
  let quantity = (amountUsdt * leverage) / (quantoMultiplier * currentPrice);
  
  // â­ï¸ å…³é”®ï¼šå‘ä¸Šå–æ•´åˆ°æœ€å°å¼ æ•°
  quantity = Math.ceil(quantity);
  
  logger.info(`Gate.io åå‘åˆçº¦: ${quantity}å¼  (multiplier=${quantoMultiplier})`);
  
} else {
  // Binance æ­£å‘åˆçº¦æ•°é‡è®¡ç®—
  // æ•°é‡(å¸) = (ä¿è¯é‡‘ * æ æ†) / ä»·æ ¼
  let quantity = (amountUsdt * leverage) / currentPrice;
  
  // â­ï¸ ç²¾åº¦å¤„ç†ï¼šæ ¹æ®å¸ç§ä¿ç•™å°æ•°ä½
  quantity = adjustQuantityPrecision(quantity, symbol);
  
  logger.info(`Binance æ­£å‘åˆçº¦: ${quantity} ${symbol}`);
}
```

### æˆäº¤ä»·è·å–å…¼å®¹æ€§

```typescript
/**
 * ç»Ÿä¸€æ ¼å¼åŒ–æˆäº¤æ•°æ®ï¼Œå…¼å®¹Gate.ioå’ŒBinance
 */
function formatTradeRecord(trade: any): {
  id: string;
  price: string;
  size: string;
  fee: string;
  timestamp: number;
} {
  return {
    id: trade.id?.toString() || trade.orderId?.toString() || trade.tradeId?.toString() || '',
    // Gate.io: price / deal_price, Binance: price / avgPrice
    price: trade.price?.toString() || trade.avgPrice?.toString() || trade.deal_price?.toString() || '0',
    // Gate.io: size / amount, Binance: qty / executedQty
    size: trade.size?.toString() || trade.qty?.toString() || trade.amount?.toString() || '0',
    // Gate.io: fee_amount, Binance: commission
    fee: trade.fee?.toString() || trade.commission?.toString() || trade.fee_amount?.toString() || '0',
    // Gate.io: create_time (ç§’çº§), Binance: time (æ¯«ç§’çº§)
    timestamp: Number(trade.timestamp || trade.time || trade.create_time || Date.now()),
  };
}
```

### æ¡ä»¶å•å…¼å®¹æ€§å¤„ç†

```typescript
// Gate.io: ä½¿ç”¨ price_orders API
async getPriceOrders() {
  const response = await this.client.futuresClient.listFuturesPriceTriggeredOrders('usdt');
  return response.map(o => ({
    id: o.id?.toString(),
    symbol: this.extractSymbol(o.initial.contract),
    type: o.trigger.price_type === 2 ? 'stop_loss' : 'take_profit',
    trigger_price: o.trigger.price,
    quantity: Math.abs(parseFloat(o.initial.size || '0')),
    status: o.status,
  }));
}

// Binance: ä½¿ç”¨ allOpenOrders API
async getPriceOrders() {
  const response = await this.client.futuresOpenOrders();
  return response
    .filter((o: any) => o.type === 'STOP_MARKET' || o.type === 'TAKE_PROFIT_MARKET')
    .map(o => ({
      id: o.orderId?.toString(),
      symbol: this.extractSymbol(o.symbol),
      type: o.type === 'STOP_MARKET' ? 'stop_loss' : 'take_profit',
      trigger_price: o.stopPrice,
      quantity: Math.abs(parseFloat(o.origQty || '0')),
      status: o.status === 'NEW' ? 'active' : 'triggered',
    }));
}
```

---

## å¼‚å¸¸çŠ¶æ€ç®¡ç†

### ä¸ä¸€è‡´çŠ¶æ€æ£€æµ‹è¡¨è®¾è®¡

```sql
-- æ–‡ä»¶: src/database/schema.ts

-- ä¸ä¸€è‡´çŠ¶æ€è®°å½•è¡¨
CREATE TABLE IF NOT EXISTS inconsistent_states (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  operation TEXT NOT NULL,           -- æ“ä½œç±»å‹: 'close_position', 'open_position', 'price_order_triggered' ç­‰
  symbol TEXT NOT NULL,               -- å¸ç§
  side TEXT,                         -- æ–¹å‘: 'long' / 'short'
  exchange_success BOOLEAN NOT NULL,  -- äº¤æ˜“æ‰€æ“ä½œæ˜¯å¦æˆåŠŸ
  db_success BOOLEAN NOT NULL,        -- æ•°æ®åº“æ“ä½œæ˜¯å¦æˆåŠŸ
  exchange_order_id TEXT,            -- äº¤æ˜“æ‰€è®¢å•ID
  error_message TEXT,                -- é”™è¯¯ä¿¡æ¯
  resolved BOOLEAN DEFAULT 0,         -- æ˜¯å¦å·²è§£å†³
  resolved_at TEXT,                  -- è§£å†³æ—¶é—´
  resolved_by TEXT,                  -- è§£å†³æ–¹å¼ (auto/manual)
  resolution_notes TEXT,             -- è§£å†³å¤‡æ³¨
  created_at TEXT NOT NULL           -- åˆ›å»ºæ—¶é—´
);

CREATE INDEX IF NOT EXISTS idx_inconsistent_states_resolved 
ON inconsistent_states(resolved, created_at);

CREATE INDEX IF NOT EXISTS idx_inconsistent_states_symbol 
ON inconsistent_states(symbol);

CREATE INDEX IF NOT EXISTS idx_inconsistent_states_operation 
ON inconsistent_states(operation);
```

### å¼‚å¸¸çŠ¶æ€åˆ†ç±»ä¸å¤„ç†ç­–ç•¥

| åœºæ™¯ | äº¤æ˜“æ‰€çŠ¶æ€ | æ•°æ®åº“çŠ¶æ€ | é£é™©ç­‰çº§ | å¤„ç†ç­–ç•¥ |
|-----|----------|----------|---------|---------|
| **åœºæ™¯A: æ­£å¸¸** | æˆåŠŸ | æˆåŠŸ | âœ… æ— é£é™© | æ— éœ€å¤„ç† |
| **åœºæ™¯B: äº¤æ˜“æ‰€å¤±è´¥** | å¤±è´¥ | æœªæ‰§è¡Œ | âš ï¸ ä½é£é™© | è¿”å›é”™è¯¯ï¼ŒAIé‡è¯• |
| **åœºæ™¯C: æ•°æ®åº“å¤±è´¥** | æˆåŠŸ | å¤±è´¥ | ğŸ”´ é«˜é£é™© | è®°å½•å¼‚å¸¸çŠ¶æ€ï¼Œäººå·¥ä»‹å…¥ |
| **åœºæ™¯D: éƒ¨åˆ†æˆåŠŸ** | æˆåŠŸ | éƒ¨åˆ†å¤±è´¥ | ğŸŸ  ä¸­é£é™© | è®°å½•å¼‚å¸¸ï¼Œå°è¯•è‡ªåŠ¨ä¿®å¤ |

### å¼‚å¸¸çŠ¶æ€è‡ªåŠ¨ä¿®å¤é€»è¾‘

```typescript
// æ–‡ä»¶: src/scheduler/inconsistentStateResolver.ts

import { createClient } from "@libsql/client";
import { getExchangeClient } from "../exchanges";
import { createLogger } from "../utils/logger";

const logger = createLogger({
  name: "inconsistent-state-resolver",
  level: "info",
});

const dbClient = createClient({
  url: process.env.DATABASE_URL || "file:./.voltagent/trading.db",
});

/**
 * ä¸ä¸€è‡´çŠ¶æ€è‡ªåŠ¨ä¿®å¤æœåŠ¡
 * å®šæœŸæ£€æŸ¥å¹¶å°è¯•ä¿®å¤æ•°æ®ä¸ä¸€è‡´é—®é¢˜
 */
export class InconsistentStateResolver {
  private resolveInterval: NodeJS.Timeout | null = null;

  /**
   * å¯åŠ¨è‡ªåŠ¨ä¿®å¤æœåŠ¡
   */
  async start() {
    if (this.resolveInterval) {
      logger.warn('è‡ªåŠ¨ä¿®å¤æœåŠ¡å·²åœ¨è¿è¡Œ');
      return;
    }

    const intervalMinutes = parseInt(process.env.RESOLVE_INTERVAL_MINUTES || '10');
    logger.info(`å¯åŠ¨ä¸ä¸€è‡´çŠ¶æ€è‡ªåŠ¨ä¿®å¤æœåŠ¡ï¼Œæ£€æµ‹é—´éš”: ${intervalMinutes}åˆ†é’Ÿ`);

    // ç«‹å³æ‰§è¡Œç¬¬ä¸€æ¬¡
    await this.resolveInconsistentStates();

    // å®šæœŸæ‰§è¡Œ
    this.resolveInterval = setInterval(async () => {
      await this.resolveInconsistentStates();
    }, intervalMinutes * 60 * 1000);
  }

  /**
   * åœæ­¢è‡ªåŠ¨ä¿®å¤æœåŠ¡
   */
  stop() {
    if (this.resolveInterval) {
      clearInterval(this.resolveInterval);
      this.resolveInterval = null;
      logger.info('è‡ªåŠ¨ä¿®å¤æœåŠ¡å·²åœæ­¢');
    }
  }

  /**
   * è§£å†³ä¸ä¸€è‡´çŠ¶æ€
   */
  private async resolveInconsistentStates() {
    try {
      // æŸ¥è¯¢æ‰€æœ‰æœªè§£å†³çš„ä¸ä¸€è‡´çŠ¶æ€
      const result = await dbClient.execute({
        sql: `SELECT * FROM inconsistent_states 
              WHERE resolved = 0 
              ORDER BY created_at ASC`
      });

      if (result.rows.length === 0) {
        logger.debug('æ²¡æœ‰å¾…è§£å†³çš„ä¸ä¸€è‡´çŠ¶æ€');
        return;
      }

      logger.info(`å‘ç° ${result.rows.length} ä¸ªå¾…è§£å†³çš„ä¸ä¸€è‡´çŠ¶æ€ï¼Œå¼€å§‹å¤„ç†...`);

      for (const row of result.rows) {
        const state: any = row;
        
        try {
          const resolved = await this.resolveState(state);
          
          if (resolved) {
            // æ ‡è®°ä¸ºå·²è§£å†³
            await dbClient.execute({
              sql: `UPDATE inconsistent_states 
                    SET resolved = 1, resolved_at = ?, resolved_by = 'auto'
                    WHERE id = ?`,
              args: [new Date().toISOString(), state.id]
            });
            logger.info(`âœ… å·²è‡ªåŠ¨ä¿®å¤ä¸ä¸€è‡´çŠ¶æ€ #${state.id}: ${state.operation} ${state.symbol}`);
          }
        } catch (error: any) {
          logger.error(`âŒ ä¿®å¤ä¸ä¸€è‡´çŠ¶æ€ #${state.id} å¤±è´¥:`, error.message);
        }
      }
    } catch (error: any) {
      logger.error('å¤„ç†ä¸ä¸€è‡´çŠ¶æ€å¤±è´¥:', error);
    }
  }

  /**
   * è§£å†³å•ä¸ªä¸ä¸€è‡´çŠ¶æ€
   */
  private async resolveState(state: any): Promise<boolean> {
    const exchangeClient = getExchangeClient();

    // æ ¹æ®æ“ä½œç±»å‹åˆ†åˆ«å¤„ç†
    switch (state.operation) {
      case 'close_position':
        return await this.resolveClosePosition(state, exchangeClient);
      
      case 'open_position':
        return await this.resolveOpenPosition(state, exchangeClient);
      
      case 'price_order_triggered':
        return await this.resolvePriceOrderTriggered(state, exchangeClient);
      
      default:
        logger.warn(`æœªçŸ¥çš„æ“ä½œç±»å‹: ${state.operation}`);
        return false;
    }
  }

  /**
   * ä¿®å¤å¹³ä»“æ“ä½œä¸ä¸€è‡´
   * 
   * æƒ…å†µ: äº¤æ˜“æ‰€å·²å¹³ä»“ï¼Œä½†æ•°æ®åº“è®°å½•å¤±è´¥
   * ç­–ç•¥: è¡¥å……æ•°æ®åº“è®°å½•
   */
  private async resolveClosePosition(state: any, exchangeClient: any): Promise<boolean> {
    const { symbol, side, exchange_order_id } = state;

    logger.info(`ğŸ”§ ä¿®å¤å¹³ä»“ä¸ä¸€è‡´: ${symbol} ${side}`);

    try {
      // 1. éªŒè¯äº¤æ˜“æ‰€ç¡®å®å·²å¹³ä»“
      const positions = await exchangeClient.getPositions();
      const contract = exchangeClient.normalizeContract(symbol);
      const positionExists = positions.some((p: any) => 
        p.contract === contract && Math.abs(parseFloat(p.size || '0')) > 0
      );

      if (positionExists) {
        logger.warn(`${symbol} æŒä»“ä»å­˜åœ¨ï¼Œæ— éœ€ä¿®å¤`);
        return false;
      }

      // 2. æŸ¥è¯¢äº¤æ˜“æ‰€çš„æˆäº¤è®°å½•
      const trades = await exchangeClient.getMyTrades(contract, 100);
      const closeTrade = trades.find((t: any) => 
        (t.orderId?.toString() === exchange_order_id) ||
        (t.order_id?.toString() === exchange_order_id)
      );

      if (!closeTrade) {
        logger.warn(`æœªæ‰¾åˆ°è®¢å• ${exchange_order_id} çš„æˆäº¤è®°å½•`);
        return false;
      }

      // 3. æŸ¥è¯¢å¼€ä»“ä¿¡æ¯ï¼ˆç”¨äºè®¡ç®—ç›ˆäºï¼‰
      const openTradeResult = await dbClient.execute({
        sql: `SELECT * FROM trades 
              WHERE symbol = ? AND side = ? AND type = 'open' 
              ORDER BY timestamp DESC LIMIT 1`,
        args: [symbol, side]
      });

      if (openTradeResult.rows.length === 0) {
        logger.warn(`æœªæ‰¾åˆ° ${symbol} ${side} çš„å¼€ä»“è®°å½•`);
        return false;
      }

      const openTrade: any = openTradeResult.rows[0];
      const entryPrice = parseFloat(openTrade.price);
      const exitPrice = parseFloat(closeTrade.price);
      const quantity = Math.abs(parseFloat(closeTrade.size));
      const leverage = openTrade.leverage || 1;

      // 4. è®¡ç®—ç›ˆäº
      const grossPnl = await exchangeClient.calculatePnl(
        entryPrice, exitPrice, quantity, side, contract
      );

      const contractType = exchangeClient.getContractType();
      let positionValue: number;
      if (contractType === 'inverse') {
        const quantoMultiplier = await getQuantoMultiplier(contract);
        positionValue = quantity * quantoMultiplier * exitPrice;
      } else {
        positionValue = quantity * exitPrice;
      }

      const totalFee = positionValue * 0.001; // 0.1%
      const netPnl = grossPnl - totalFee;
      const priceChangePercent = side === "long"
        ? ((exitPrice - entryPrice) / entryPrice) * 100
        : ((entryPrice - exitPrice) / entryPrice) * 100;
      const pnlPercent = priceChangePercent * leverage;

      // 5. å¼€å¯äº‹åŠ¡è¡¥å……æ•°æ®åº“è®°å½•
      const timestamp = new Date().toISOString();
      await dbClient.execute('BEGIN TRANSACTION');

      try {
        // åˆ é™¤æŒä»“è®°å½•
        await dbClient.execute({
          sql: 'DELETE FROM positions WHERE symbol = ? AND side = ?',
          args: [symbol, side]
        });

        // æ›´æ–°æ¡ä»¶å•çŠ¶æ€
        await dbClient.execute({
          sql: `UPDATE price_orders 
                SET status = 'cancelled', updated_at = ?
                WHERE symbol = ? AND side = ? AND status = 'active'`,
          args: [timestamp, symbol, side]
        });

        // æ’å…¥äº¤æ˜“è®°å½•
        await dbClient.execute({
          sql: `INSERT INTO trades 
                (order_id, symbol, side, type, price, quantity, leverage, pnl, fee, timestamp, status)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          args: [
            exchange_order_id, symbol, side, 'close',
            exitPrice, quantity, leverage, netPnl, totalFee, timestamp, 'filled'
          ]
        });

        // æ’å…¥å¹³ä»“äº‹ä»¶
        await dbClient.execute({
          sql: `INSERT INTO position_close_events 
                (symbol, side, entry_price, close_price, quantity, leverage,
                 pnl, pnl_percent, fee, close_reason, trigger_type, order_id,
                 created_at, processed)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          args: [
            symbol, side, entryPrice, exitPrice, quantity, leverage,
            netPnl, pnlPercent, totalFee, 'system_recovered', 'auto_fix',
            exchange_order_id, timestamp, 1
          ]
        });

        await dbClient.execute('COMMIT');
        logger.info(`âœ… å·²è¡¥å…… ${symbol} çš„å¹³ä»“è®°å½•`);
        return true;

      } catch (dbError: any) {
        await dbClient.execute('ROLLBACK');
        logger.error('è¡¥å……æ•°æ®åº“è®°å½•å¤±è´¥:', dbError);
        return false;
      }

    } catch (error: any) {
      logger.error('ä¿®å¤å¹³ä»“ä¸ä¸€è‡´å¤±è´¥:', error);
      return false;
    }
  }

  /**
   * ä¿®å¤å¼€ä»“æ“ä½œä¸ä¸€è‡´
   * 
   * æƒ…å†µ: äº¤æ˜“æ‰€å·²å¼€ä»“ï¼Œä½†æ•°æ®åº“è®°å½•å¤±è´¥
   * ç­–ç•¥: è¡¥å……æ•°æ®åº“è®°å½•ï¼Œå¹¶è®¾ç½®æ­¢æŸæ­¢ç›ˆ
   */
  private async resolveOpenPosition(state: any, exchangeClient: any): Promise<boolean> {
    // TODO: å®ç°å¼€ä»“ä¸ä¸€è‡´ä¿®å¤é€»è¾‘
    logger.warn('å¼€ä»“ä¸ä¸€è‡´ä¿®å¤å°šæœªå®ç°');
    return false;
  }

  /**
   * ä¿®å¤æ¡ä»¶å•è§¦å‘ä¸ä¸€è‡´
   * 
   * æƒ…å†µ: æ¡ä»¶å•åœ¨äº¤æ˜“æ‰€è§¦å‘ï¼Œä½†æ•°æ®åº“æœªæ›´æ–°
   * ç­–ç•¥: ä¸resolveClosePositionç±»ä¼¼
   */
  private async resolvePriceOrderTriggered(state: any, exchangeClient: any): Promise<boolean> {
    // å¤ç”¨ resolveClosePosition çš„é€»è¾‘
    return await this.resolveClosePosition(state, exchangeClient);
  }
}

// å¯¼å‡ºå•ä¾‹
export const inconsistentStateResolver = new InconsistentStateResolver();
```

---

## å¥åº·æ£€æŸ¥ç³»ç»Ÿ

### å¥åº·æ£€æŸ¥ä»»åŠ¡è®¾è®¡

```typescript
// æ–‡ä»¶: src/scheduler/healthCheck.ts

import { createClient } from "@libsql/client";
import { getExchangeClient } from "../exchanges";
import { createLogger } from "../utils/logger";
import { parsePositionSize } from "../utils";

const logger = createLogger({
  name: "health-check",
  level: "info",
});

const dbClient = createClient({
  url: process.env.DATABASE_URL || "file:./.voltagent/trading.db",
});

/**
 * å¥åº·æ£€æŸ¥ç»“æœæ¥å£
 */
interface HealthCheckResult {
  healthy: boolean;
  issues: string[];
  warnings: string[];
  timestamp: string;
  details: {
    orphanOrders: number;
    inconsistentStates: number;
    positionMismatches: {
      onlyInExchange: string[];
      onlyInDB: string[];
    };
    priceOrderMismatches: {
      activeButNoPosition: string[];
      positionButNoOrders: string[];
    };
  };
}

/**
 * å¥åº·æ£€æŸ¥ä»»åŠ¡ - æ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
 */
export async function performHealthCheck(): Promise<HealthCheckResult> {
  logger.info('ğŸ¥ å¼€å§‹å¥åº·æ£€æŸ¥...');
  
  const issues: string[] = [];
  const warnings: string[] = [];
  const details: any = {
    orphanOrders: 0,
    inconsistentStates: 0,
    positionMismatches: { onlyInExchange: [], onlyInDB: [] },
    priceOrderMismatches: { activeButNoPosition: [], positionButNoOrders: [] },
  };
  
  try {
    // ========== æ£€æŸ¥é¡¹1: å­¤å„¿æ¡ä»¶å• ==========
    logger.debug('æ£€æŸ¥1: å­¤å„¿æ¡ä»¶å•...');
    
    const orphanOrders = await dbClient.execute(`
      SELECT po.* 
      FROM price_orders po
      LEFT JOIN positions p ON po.symbol = p.symbol AND po.side = p.side
      WHERE po.status = 'active' 
      AND p.symbol IS NULL
    `);
    
    if (orphanOrders.rows.length > 0) {
      details.orphanOrders = orphanOrders.rows.length;
      warnings.push(`å‘ç° ${orphanOrders.rows.length} ä¸ªå­¤å„¿æ¡ä»¶å•`);
      logger.warn(`âš ï¸ å‘ç° ${orphanOrders.rows.length} ä¸ªå­¤å„¿æ¡ä»¶å•`);
      
      // è‡ªåŠ¨ä¿®å¤: æ ‡è®°ä¸ºcancelled
      for (const order of orphanOrders.rows) {
        await dbClient.execute({
          sql: `UPDATE price_orders 
                SET status = 'cancelled', updated_at = ?
                WHERE order_id = ?`,
          args: [new Date().toISOString(), order.order_id]
        });
      }
      logger.info('âœ… å·²è‡ªåŠ¨æ¸…ç†å­¤å„¿æ¡ä»¶å•');
    } else {
      logger.debug('âœ… æ— å­¤å„¿æ¡ä»¶å•');
    }
    
    // ========== æ£€æŸ¥é¡¹2: æœªè§£å†³çš„ä¸ä¸€è‡´çŠ¶æ€ ==========
    logger.debug('æ£€æŸ¥2: ä¸ä¸€è‡´çŠ¶æ€...');
    
    const inconsistentStates = await dbClient.execute(`
      SELECT * FROM inconsistent_states 
      WHERE resolved = 0 
      ORDER BY created_at DESC
    `);
    
    if (inconsistentStates.rows.length > 0) {
      details.inconsistentStates = inconsistentStates.rows.length;
      issues.push(`å‘ç° ${inconsistentStates.rows.length} ä¸ªæœªè§£å†³çš„ä¸ä¸€è‡´çŠ¶æ€`);
      logger.error(`âŒ å‘ç° ${inconsistentStates.rows.length} ä¸ªæœªè§£å†³çš„ä¸ä¸€è‡´çŠ¶æ€`);
      
      for (const state of inconsistentStates.rows) {
        logger.error(`  - ${state.operation} ${state.symbol}: ${state.error_message}`);
      }
    } else {
      logger.debug('âœ… æ— ä¸ä¸€è‡´çŠ¶æ€');
    }
    
    // ========== æ£€æŸ¥é¡¹3: äº¤æ˜“æ‰€ä¸æ•°æ®åº“æŒä»“å¯¹æ¯” ==========
    logger.debug('æ£€æŸ¥3: æŒä»“ä¸€è‡´æ€§...');
    
    const exchangeClient = getExchangeClient();
    const exchangePositions = await exchangeClient.getPositions();
    const dbPositions = await dbClient.execute('SELECT * FROM positions');
    
    // æ„å»ºé›†åˆ
    const exchangeKeys = new Set(
      exchangePositions
        .filter((p: any) => Math.abs(parsePositionSize(p.size)) > 0)
        .map((p: any) => {
          const symbol = exchangeClient.extractSymbol(p.contract);
          const side = parsePositionSize(p.size) > 0 ? 'long' : 'short';
          return `${symbol}_${side}`;
        })
    );
    
    const dbKeys = new Set(
      dbPositions.rows.map((p: any) => `${p.symbol}_${p.side}`)
    );
    
    // æ‰¾å‡ºå·®å¼‚
    const onlyInExchange = [...exchangeKeys].filter(k => !dbKeys.has(k));
    const onlyInDB = [...dbKeys].filter(k => !exchangeKeys.has(k));
    
    if (onlyInExchange.length > 0) {
      details.positionMismatches.onlyInExchange = onlyInExchange;
      warnings.push(`äº¤æ˜“æ‰€æœ‰ä½†æ•°æ®åº“æ²¡æœ‰çš„æŒä»“: ${onlyInExchange.length}ä¸ª`);
      logger.warn(`âš ï¸ äº¤æ˜“æ‰€æœ‰ä½†æ•°æ®åº“æ²¡æœ‰çš„æŒä»“: ${onlyInExchange.join(', ')}`);
    }
    
    if (onlyInDB.length > 0) {
      details.positionMismatches.onlyInDB = onlyInDB;
      warnings.push(`æ•°æ®åº“æœ‰ä½†äº¤æ˜“æ‰€æ²¡æœ‰çš„æŒä»“: ${onlyInDB.length}ä¸ª`);
      logger.warn(`âš ï¸ æ•°æ®åº“æœ‰ä½†äº¤æ˜“æ‰€æ²¡æœ‰çš„æŒä»“: ${onlyInDB.join(', ')}`);
    }
    
    if (onlyInExchange.length === 0 && onlyInDB.length === 0) {
      logger.debug('âœ… æŒä»“ä¸€è‡´');
    }
    
    // ========== æ£€æŸ¥é¡¹4: æ¡ä»¶å•ä¸æŒä»“åŒ¹é… ==========
    logger.debug('æ£€æŸ¥4: æ¡ä»¶å•ä¸æŒä»“åŒ¹é…...');
    
    // 4.1 æœ‰activeæ¡ä»¶å•ä½†æ— æŒä»“
    const activeOrdersNoPosition = await dbClient.execute(`
      SELECT DISTINCT po.symbol, po.side 
      FROM price_orders po
      LEFT JOIN positions p ON po.symbol = p.symbol AND po.side = p.side
      WHERE po.status = 'active' 
      AND p.symbol IS NULL
    `);
    
    if (activeOrdersNoPosition.rows.length > 0) {
      const keys = activeOrdersNoPosition.rows.map((r: any) => `${r.symbol}_${r.side}`);
      details.priceOrderMismatches.activeButNoPosition = keys;
      warnings.push(`æœ‰activeæ¡ä»¶å•ä½†æ— æŒä»“: ${keys.length}ä¸ª`);
      logger.warn(`âš ï¸ æœ‰activeæ¡ä»¶å•ä½†æ— æŒä»“: ${keys.join(', ')}`);
    }
    
    // 4.2 æœ‰æŒä»“ä½†æ— æ¡ä»¶å•
    const positionNoOrders = await dbClient.execute(`
      SELECT p.symbol, p.side 
      FROM positions p
      LEFT JOIN price_orders po ON p.symbol = po.symbol AND p.side = po.side AND po.status = 'active'
      WHERE po.order_id IS NULL
    `);
    
    if (positionNoOrders.rows.length > 0) {
      const keys = positionNoOrders.rows.map((r: any) => `${r.symbol}_${r.side}`);
      details.priceOrderMismatches.positionButNoOrders = keys;
      warnings.push(`æœ‰æŒä»“ä½†æ— æ¡ä»¶å•: ${keys.length}ä¸ª`);
      logger.warn(`âš ï¸ æœ‰æŒä»“ä½†æ— æ¡ä»¶å•: ${keys.join(', ')}`);
    }
    
    if (activeOrdersNoPosition.rows.length === 0 && positionNoOrders.rows.length === 0) {
      logger.debug('âœ… æ¡ä»¶å•ä¸æŒä»“åŒ¹é…');
    }
    
    // ========== æ£€æŸ¥é¡¹5: æ•°æ®åº“è¿æ¥å¥åº· ==========
    logger.debug('æ£€æŸ¥5: æ•°æ®åº“è¿æ¥...');
    
    try {
      await dbClient.execute('SELECT 1');
      logger.debug('âœ… æ•°æ®åº“è¿æ¥æ­£å¸¸');
    } catch (dbError: any) {
      issues.push('æ•°æ®åº“è¿æ¥å¼‚å¸¸');
      logger.error('âŒ æ•°æ®åº“è¿æ¥å¼‚å¸¸:', dbError.message);
    }
    
    // ========== æ£€æŸ¥é¡¹6: äº¤æ˜“æ‰€APIå¥åº· ==========
    logger.debug('æ£€æŸ¥6: äº¤æ˜“æ‰€API...');
    
    try {
      const account = await exchangeClient.getFuturesAccount();
      if (account && account.total) {
        logger.debug('âœ… äº¤æ˜“æ‰€APIæ­£å¸¸');
      } else {
        warnings.push('äº¤æ˜“æ‰€APIå“åº”å¼‚å¸¸');
        logger.warn('âš ï¸ äº¤æ˜“æ‰€APIå“åº”å¼‚å¸¸');
      }
    } catch (apiError: any) {
      issues.push('äº¤æ˜“æ‰€APIè¿æ¥å¤±è´¥');
      logger.error('âŒ äº¤æ˜“æ‰€APIè¿æ¥å¤±è´¥:', apiError.message);
    }
    
  } catch (error: any) {
    issues.push(`å¥åº·æ£€æŸ¥æ‰§è¡Œå¤±è´¥: ${error.message}`);
    logger.error('âŒ å¥åº·æ£€æŸ¥æ‰§è¡Œå¤±è´¥:', error);
  }
  
  // ========== æ±‡æ€»ç»“æœ ==========
  const healthy = issues.length === 0 && warnings.length === 0;
  const result: HealthCheckResult = {
    healthy,
    issues,
    warnings,
    timestamp: new Date().toISOString(),
    details,
  };
  
  if (healthy) {
    logger.info('âœ… å¥åº·æ£€æŸ¥é€šè¿‡ï¼Œç³»ç»Ÿè¿è¡Œæ­£å¸¸');
  } else if (issues.length > 0) {
    logger.error(`âŒ å¥åº·æ£€æŸ¥å‘ç° ${issues.length} ä¸ªä¸¥é‡é—®é¢˜ï¼Œ${warnings.length} ä¸ªè­¦å‘Š`);
    issues.forEach((issue, i) => logger.error(`   ${i + 1}. ${issue}`));
  } else {
    logger.warn(`âš ï¸ å¥åº·æ£€æŸ¥å‘ç° ${warnings.length} ä¸ªè­¦å‘Š`);
    warnings.forEach((warning, i) => logger.warn(`   ${i + 1}. ${warning}`));
  }
  
  return result;
}

/**
 * å¯åŠ¨å¥åº·æ£€æŸ¥å®šæ—¶ä»»åŠ¡
 */
export function startHealthCheck() {
  // ç«‹å³æ‰§è¡Œä¸€æ¬¡
  performHealthCheck();
  
  // æ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
  const intervalMinutes = parseInt(process.env.HEALTH_CHECK_INTERVAL_MINUTES || '5');
  setInterval(() => {
    performHealthCheck();
  }, intervalMinutes * 60 * 1000);
  
  logger.info(`âœ… å¥åº·æ£€æŸ¥ä»»åŠ¡å·²å¯åŠ¨ (æ¯${intervalMinutes}åˆ†é’Ÿ)`);
}
```

---

## å®æ–½æ­¥éª¤

### ç¬¬ä¸€æ­¥: åˆ›å»ºä¸ä¸€è‡´çŠ¶æ€æ£€æµ‹è¡¨

```bash
# 1. åˆ›å»ºè¿ç§»è„šæœ¬
cat > src/database/migrate-add-inconsistent-states.ts << 'EOF'
/**
 * æ·»åŠ ä¸ä¸€è‡´çŠ¶æ€è¿½è¸ªè¡¨
 */
import { createClient } from "@libsql/client";

const dbClient = createClient({
  url: process.env.DATABASE_URL || "file:./.voltagent/trading.db",
});

async function migrate() {
  console.log('åˆ›å»º inconsistent_states è¡¨...');
  
  await dbClient.execute(`
    CREATE TABLE IF NOT EXISTS inconsistent_states (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      operation TEXT NOT NULL,
      symbol TEXT NOT NULL,
      side TEXT,
      exchange_success BOOLEAN NOT NULL,
      db_success BOOLEAN NOT NULL,
      exchange_order_id TEXT,
      error_message TEXT,
      resolved BOOLEAN DEFAULT 0,
      resolved_at TEXT,
      resolved_by TEXT,
      resolution_notes TEXT,
      created_at TEXT NOT NULL
    );
  `);
  
  await dbClient.execute(`
    CREATE INDEX IF NOT EXISTS idx_inconsistent_states_resolved 
    ON inconsistent_states(resolved, created_at);
  `);
  
  await dbClient.execute(`
    CREATE INDEX IF NOT EXISTS idx_inconsistent_states_symbol 
    ON inconsistent_states(symbol);
  `);
  
  await dbClient.execute(`
    CREATE INDEX IF NOT EXISTS idx_inconsistent_states_operation 
    ON inconsistent_states(operation);
  `);
  
  console.log('âœ… inconsistent_states è¡¨åˆ›å»ºæˆåŠŸ');
}

migrate()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error('âŒ è¿ç§»å¤±è´¥:', error);
    process.exit(1);
  });
EOF

# 2. æ‰§è¡Œè¿ç§»
npm run tsx src/database/migrate-add-inconsistent-states.ts
```

### ç¬¬äºŒæ­¥: ä¿®æ”¹å¹³ä»“å·¥å…·ï¼ˆäº‹åŠ¡ä¿æŠ¤ï¼‰

```bash
# 1. å¤‡ä»½åŸæ–‡ä»¶
cp src/tools/trading/tradeExecution.ts src/tools/trading/tradeExecution.ts.backup_$(date +%Y%m%d_%H%M%S)

# 2. åº”ç”¨ä¿®æ”¹
# æŒ‰ç…§"æ–¹æ¡ˆ1.1"ä¸­çš„ä»£ç ä¿®æ”¹ closePositionTool
# æ ¸å¿ƒè¦ç‚¹:
#   - é˜¶æ®µ1: å®Œæˆæ‰€æœ‰äº¤æ˜“æ‰€æ“ä½œ
#   - é˜¶æ®µ2: æ•°æ®åº“äº‹åŠ¡æ“ä½œ
#   - äº‹åŠ¡å†…æœ€å…ˆåˆ é™¤ positions è®°å½•
#   - å¤±è´¥æ—¶è®°å½•åˆ° inconsistent_states è¡¨

# 3. ç¼–è¯‘æ£€æŸ¥
npm run build

# 4. æµ‹è¯•
npm run test -- closePositionTool
```

### ç¬¬ä¸‰æ­¥: ä¿®æ”¹æ¡ä»¶å•ç›‘æ§ï¼ˆäº‹åŠ¡ä¿æŠ¤ï¼‰

```bash
# 1. å¤‡ä»½åŸæ–‡ä»¶
cp src/scheduler/priceOrderMonitor.ts src/scheduler/priceOrderMonitor.ts.backup_$(date +%Y%m%d_%H%M%S)

# 2. åº”ç”¨ä¿®æ”¹
# æŒ‰ç…§"æ–¹æ¡ˆ1.2"ä¸­çš„ä»£ç ä¿®æ”¹ handleTriggeredOrder
# æ ¸å¿ƒè¦ç‚¹:
#   - ä½¿ç”¨äº‹åŠ¡åŒ…è£¹æ•°æ®åº“æ“ä½œ
#   - æœ€å…ˆåˆ é™¤ positions è®°å½•
#   - å¤±è´¥æ—¶è®°å½•åˆ° inconsistent_states è¡¨

# 3. ç¼–è¯‘æ£€æŸ¥
npm run build

# 4. æµ‹è¯•
npm run test -- priceOrderMonitor
```

### ç¬¬å››æ­¥: æ·»åŠ å¥åº·æ£€æŸ¥æœåŠ¡

```bash
# 1. åˆ›å»ºå¥åº·æ£€æŸ¥æ–‡ä»¶
# æŒ‰ç…§"å¥åº·æ£€æŸ¥ç³»ç»Ÿ"ç« èŠ‚ä¸­çš„ä»£ç åˆ›å»º src/scheduler/healthCheck.ts

# 2. åœ¨ä¸»å…¥å£ä¸­å¯åŠ¨
# ç¼–è¾‘ src/index.tsï¼Œæ·»åŠ :
import { startHealthCheck } from './scheduler/healthCheck.js';

// åœ¨å¯åŠ¨å‡½æ•°ä¸­æ·»åŠ :
startHealthCheck();

# 3. é…ç½®ç¯å¢ƒå˜é‡ï¼ˆå¯é€‰ï¼‰
cat >> .env << EOF
# å¥åº·æ£€æŸ¥é—´éš”æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰

### ç¬¬äº”æ­¥: æ·»åŠ è‡ªåŠ¨ä¿®å¤æœåŠ¡

```bash
# 1. åˆ›å»ºè‡ªåŠ¨ä¿®å¤æœåŠ¡æ–‡ä»¶
# æŒ‰ç…§"å¼‚å¸¸çŠ¶æ€è‡ªåŠ¨ä¿®å¤é€»è¾‘"ç« èŠ‚ä¸­çš„ä»£ç åˆ›å»º src/scheduler/inconsistentStateResolver.ts

# 2. åœ¨ä¸»å…¥å£ä¸­å¯åŠ¨
# ç¼–è¾‘ src/index.tsï¼Œæ·»åŠ :
import { inconsistentStateResolver } from './scheduler/inconsistentStateResolver.js';

// åœ¨å¯åŠ¨å‡½æ•°ä¸­æ·»åŠ :
inconsistentStateResolver.start();

# 3. é…ç½®ç¯å¢ƒå˜é‡ï¼ˆå¯é€‰ï¼‰
cat >> .env << EOF
# è‡ªåŠ¨ä¿®å¤é—´éš”æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
RESOLVE_INTERVAL_MINUTES=10

# å¯ç”¨è‡ªåŠ¨ä¿®å¤
AUTO_RESOLVE_ENABLED=true
EOF

# 4. é‡å¯æœåŠ¡
npm start
```

### ç¬¬å…­æ­¥: æ·»åŠ é‚®ä»¶å‘Šè­¦é€šçŸ¥

**çŠ¶æ€**: å·²å®Œæˆ  
**å®Œæˆæ—¶é—´**: 2025-01-12  
**æ–°å¢æ–‡ä»¶**: `src/utils/emailAlert.ts`

**å·²å®æ–½çš„åŠŸèƒ½**:

- âœ… åˆ›å»ºé‚®ä»¶å‘Šè­¦æœåŠ¡ï¼Œæ”¯æŒ SMTP åè®®å‘é€å‘Šè­¦é‚®ä»¶
- âœ… **å‘Šè­¦åœºæ™¯1: ä¸ä¸€è‡´çŠ¶æ€æŒç»­å¢é•¿** - æ•°é‡ > 5 ä¸”è¿ç»­å¢é•¿æ—¶å‘é€ CRITICAL å‘Šè­¦
- âœ… **å‘Šè­¦åœºæ™¯2: å¥åº·æ£€æŸ¥è¿ç»­å¤±è´¥** - è¿ç»­å¤±è´¥3æ¬¡æ—¶å‘é€ ERROR å‘Šè­¦
- âœ… **å‘Šè­¦åœºæ™¯3: è‡ªåŠ¨ä¿®å¤è¿ç»­å¤±è´¥** - å•ä¸ªçŠ¶æ€å¤±è´¥5æ¬¡æˆ–æ€»å¤±è´¥10æ¬¡æ—¶å‘Šè­¦
- âœ… **å‘Šè­¦åœºæ™¯4: äº¤æ˜“æ‰€APIä¸å¯ç”¨** - è¿ç»­ä¸å¯ç”¨è¶…è¿‡5åˆ†é’Ÿæ—¶å‘Šè­¦
- âœ… æ”¯æŒå¤šçº§åˆ«å‘Šè­¦ï¼šINFOã€WARNINGã€ERRORã€CRITICAL
- âœ… è‡ªåŠ¨å»é‡æœºåˆ¶ï¼šåŒç±»å‘Šè­¦5åˆ†é’Ÿå†·å´æœŸï¼Œé¿å…é‚®ä»¶è½°ç‚¸
- âœ… ç¾åŒ–HTMLé‚®ä»¶æ¨¡æ¿ï¼ŒåŒ…å«æ—¶é—´æˆ³å’Œè¯¦ç»†ä¿¡æ¯
- âœ… å…¼å®¹ä¸»æµé‚®ç®±ï¼šGmailã€QQã€163ã€Outlookç­‰
- âœ… å¯é€‰é…ç½®ï¼šä¸é…ç½®é‚®ä»¶ä¸å½±å“ç³»ç»Ÿè¿è¡Œ
- âœ… åœ¨ä¸»ç¨‹åº `src/index.ts` ä¸­åˆå§‹åŒ–é‚®ä»¶æœåŠ¡
- âœ… åœ¨å¥åº·æ£€æŸ¥å’Œè‡ªåŠ¨ä¿®å¤æœåŠ¡ä¸­é›†æˆå‘Šè­¦é€»è¾‘
- âœ… ç¼–è¯‘æµ‹è¯•é€šè¿‡

**ç¯å¢ƒå˜é‡é…ç½®**:

```bash
# SMTP æœåŠ¡å™¨é…ç½®
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_email@gmail.com
SMTP_PASS=your_email_password

# å‘Šè­¦æ¥æ”¶é‚®ç®±
ALERT_EMAIL_FROM=your_email@gmail.com
ALERT_EMAIL_TO=alert_receiver@example.com
```

**å…³é”®ç‰¹æ€§**ï¼š

```typescript
// å‘Šè­¦è¿½è¸ªå™¨ - è¿½è¸ªè¿ç»­å¤±è´¥æ¬¡æ•°
class AlertTracker {
  private healthCheckFailures = 0;
  private apiFailureStartTime: number | null = null;
  private lastInconsistentCount = 0;
  private inconsistentGrowthCount = 0;
  
  // æ£€æµ‹ä¸ä¸€è‡´çŠ¶æ€æ˜¯å¦æŒç»­å¢é•¿
  checkInconsistentStates(count: number) {
    if (count > 5 && count > this.lastInconsistentCount) {
      this.inconsistentGrowthCount++;
      if (this.inconsistentGrowthCount >= 2) {
        emailAlertService.sendAlert({ level: AlertLevel.CRITICAL, ... });
      }
    }
  }
  
  // è®°å½•APIå¤±è´¥
  recordApiFailure() {
    const failureDuration = Date.now() - this.apiFailureStartTime;
    if (failureDuration >= 5 * 60 * 1000) {
      emailAlertService.sendAlert({ level: AlertLevel.ERROR, ... });
    }
  }
}

// ä¿®å¤å¤±è´¥è¿½è¸ªå™¨
class ResolveFailureTracker {
  private failedStates: Map<number, number> = new Map();
  
  recordFailure(stateId: number) {
    const count = (this.failedStates.get(stateId) || 0) + 1;
    if (count >= 5) {
      emailAlertService.sendAlert({ level: AlertLevel.ERROR, ... });
    }
  }
}
```

---

## å®æ–½æ€»ç»“

### å·²å®Œæˆçš„å·¥ä½œ

#### âœ… é˜¶æ®µä¸€ï¼šåŸºç¡€è®¾æ–½ï¼ˆ2025-01-12ï¼‰

1. **ä¸ä¸€è‡´çŠ¶æ€æ£€æµ‹è¡¨** (`inconsistent_states`)
   - è®°å½•æ‰€æœ‰äº¤æ˜“æ‰€æ“ä½œä¸æ•°æ®åº“æ“ä½œä¸ä¸€è‡´çš„æƒ…å†µ
   - åŒ…å«å®Œæ•´çš„é”™è¯¯ä¸Šä¸‹æ–‡ï¼ˆoperationã€symbolã€error_messageç­‰ï¼‰
   - æ”¯æŒè§£å†³çŠ¶æ€è¿½è¸ªå’Œäººå·¥å¤‡æ³¨

2. **äº‹åŠ¡ä¿æŠ¤æœºåˆ¶**
   - å¹³ä»“å·¥å…· (`closePositionTool`) å…¨é¢äº‹åŠ¡ä¿æŠ¤
   - æ¡ä»¶å•ç›‘æ§ (`priceOrderMonitor`) äº‹åŠ¡ä¿æŠ¤
   - é‡‡ç”¨"äº¤æ˜“æ‰€å…ˆè¡Œï¼Œæ•°æ®åº“äº‹åŠ¡"çš„ä¸¤é˜¶æ®µç­–ç•¥
   - æŒä»“è®°å½•åœ¨äº‹åŠ¡ä¸­ä¼˜å…ˆåˆ é™¤ï¼Œé¿å…è¯¯åˆ¤

#### âœ… é˜¶æ®µäºŒï¼šè‡ªåŠ¨åŒ–è¿ç»´ï¼ˆ2025-01-12ï¼‰

1. **å¥åº·æ£€æŸ¥æœåŠ¡** (`src/scheduler/healthCheck.ts`)
   - æ¯5åˆ†é’Ÿå…¨é¢æ£€æŸ¥ç³»ç»ŸçŠ¶æ€ï¼ˆå¯é€šè¿‡ `HEALTH_CHECK_INTERVAL_MINUTES` ç¯å¢ƒå˜é‡é…ç½®ï¼‰
   - 6å¤§æ£€æŸ¥é¡¹ï¼šå­¤å„¿æ¡ä»¶å•ã€ä¸ä¸€è‡´çŠ¶æ€ã€æŒä»“ä¸€è‡´æ€§ã€æ•°æ®åº“å¥åº·ã€APIè¿é€šæ€§ã€æ¡ä»¶å•çŠ¶æ€
   - è‡ªåŠ¨æ¸…ç†å­¤å„¿æ¡ä»¶å•
   - å…¼å®¹å¸å®‰å’ŒGate.io

2. **è‡ªåŠ¨ä¿®å¤æœåŠ¡** (`src/scheduler/inconsistentStateResolver.ts`)
   - æ¯10åˆ†é’Ÿæ‰«æå¹¶ä¿®å¤ä¸ä¸€è‡´çŠ¶æ€ï¼ˆå¯é€šè¿‡ `RESOLVE_INTERVAL_MINUTES` ç¯å¢ƒå˜é‡é…ç½®ï¼‰
   - ä»äº¤æ˜“æ‰€æŸ¥è¯¢æƒå¨æ•°æ®ä½œä¸ºä¿®å¤ä¾æ®
   - è‡ªåŠ¨è¡¥å……ç¼ºå¤±çš„æ•°æ®åº“è®°å½•
   - è‡ªåŠ¨åˆ é™¤æ®‹ç•™çš„é”™è¯¯è®°å½•
   - ä¿®å¤æˆåŠŸåæ ‡è®°ä¸ºå·²è§£å†³

3. **é‚®ä»¶å‘Šè­¦é€šçŸ¥**
   - é›†æˆé‚®ä»¶å‘Šè­¦æœåŠ¡ï¼Œæ”¯æŒSMTPåè®®
   - é…ç½®å‘Šè­¦åœºæ™¯ï¼šä¸ä¸€è‡´çŠ¶æ€å¢é•¿ã€å¥åº·æ£€æŸ¥å¤±è´¥ã€è‡ªåŠ¨ä¿®å¤å¤±è´¥ã€äº¤æ˜“æ‰€APIä¸å¯ç”¨
   - æ”¯æŒå¤šçº§åˆ«å‘Šè­¦ï¼šINFOã€WARNINGã€ERRORã€CRITICAL
   - è‡ªåŠ¨å»é‡æœºåˆ¶ï¼Œé¿å…é‚®ä»¶è½°ç‚¸

### æŠ€æœ¯äº®ç‚¹

1. âœ… **æ•°æ®ä¸€è‡´æ€§ä¿è¯** - ä½¿ç”¨äº‹åŠ¡ç¡®ä¿è¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥
2. âœ… **æ“ä½œé¡ºåºä¼˜åŒ–** - å…³é”®æ“ä½œï¼ˆåˆ é™¤æŒä»“ï¼‰æ”¾åœ¨äº‹åŠ¡æœ€å‰é¢
3. âœ… **å¼‚å¸¸çŠ¶æ€è¿½è¸ª** - ä¸ä¸€è‡´å‘ç”Ÿæ—¶æœ‰å®Œæ•´çš„è®°å½•å¯è¿½æº¯
4. âœ… **è‡ªåŠ¨åŒ–æ£€æµ‹** - å®šæœŸå¥åº·æ£€æŸ¥ï¼ŒåŠæ—¶å‘ç°é—®é¢˜
5. âœ… **è‡ªåŠ¨åŒ–ä¿®å¤** - å¤§éƒ¨åˆ†ä¸ä¸€è‡´çŠ¶æ€å¯è‡ªåŠ¨æ¢å¤
6. âœ… **å¤šäº¤æ˜“æ‰€å…¼å®¹** - ç»Ÿä¸€æ¥å£ï¼Œæ”¯æŒå¸å®‰å’ŒGate.io
7. âœ… **é™ä½é£é™©** - å³ä½¿éƒ¨åˆ†å¤±è´¥ï¼Œä¹Ÿä¸ä¼šäº§ç”Ÿä¸¥é‡åæœ

### è¿ç»´è¦ç‚¹

#### å¯åŠ¨æ§åˆ¶

```bash
# é»˜è®¤å¯åŠ¨ï¼ˆå¥åº·æ£€æŸ¥é»˜è®¤å¯ç”¨ï¼Œè‡ªåŠ¨ä¿®å¤é»˜è®¤ç¦ç”¨ï¼‰
npm start

# å®Œæ•´å¯åŠ¨ï¼ˆåŒ…å«å¥åº·æ£€æŸ¥å’Œè‡ªåŠ¨ä¿®å¤ï¼‰
AUTO_RESOLVE_ENABLED=true npm start

# ç¦ç”¨å¥åº·æ£€æŸ¥
HEALTH_CHECK_ENABLED=false npm start

# ä»…å¯ç”¨è‡ªåŠ¨ä¿®å¤ï¼ˆç¦ç”¨å¥åº·æ£€æŸ¥ï¼‰
HEALTH_CHECK_ENABLED=false AUTO_RESOLVE_ENABLED=true npm start

# ç¦ç”¨æ‰€æœ‰è‡ªåŠ¨åŒ–æœåŠ¡ï¼ˆä»…æ ¸å¿ƒäº¤æ˜“ï¼‰
HEALTH_CHECK_ENABLED=false npm start
```

#### ç›‘æ§å‘½ä»¤

```bash
# æŸ¥çœ‹ä¸ä¸€è‡´çŠ¶æ€ç»Ÿè®¡
sqlite3 .voltagent/trading.db "SELECT operation, COUNT(*) FROM inconsistent_states WHERE resolved=0 GROUP BY operation;"

# æŸ¥çœ‹æœ€è¿‘çš„ä¸ä¸€è‡´è®°å½•
sqlite3 .voltagent/trading.db "SELECT * FROM inconsistent_states ORDER BY created_at DESC LIMIT 10;"

# ç›‘æ§æ—¥å¿—å…³é”®è¯
tail -f logs/pm2-out.log | grep -E "å¥åº·æ£€æŸ¥|è‡ªåŠ¨ä¿®å¤|inconsistent|ROLLBACK"
```

#### å‘Šè­¦è®¾ç½®

  âœ… å·²å®æ–½é‚®ä»¶å‘Šè­¦ç³»ç»Ÿ**

ç³»ç»Ÿå·²é›†æˆé‚®ä»¶å‘Šè­¦æœåŠ¡ï¼Œå½“å‡ºç°ä»¥ä¸‹ä¸¥é‡æƒ…å†µæ—¶ä¼šè‡ªåŠ¨å‘é€é‚®ä»¶é€šçŸ¥ï¼š

**å‘Šè­¦è§¦å‘æ¡ä»¶**ï¼š

1. âœ… **ä¸ä¸€è‡´çŠ¶æ€æŒç»­å¢é•¿** - å½“ä¸ä¸€è‡´çŠ¶æ€æ•°é‡ > 5 ä¸”è¿ç»­2æ¬¡æ£€æŸ¥éƒ½åœ¨å¢é•¿æ—¶ï¼Œå‘é€ CRITICAL çº§åˆ«å‘Šè­¦
2. âœ… **å¥åº·æ£€æŸ¥è¿ç»­å¤±è´¥** - è¿ç»­å¤±è´¥3æ¬¡æ—¶ï¼Œå‘é€ ERROR çº§åˆ«å‘Šè­¦
3. âœ… **è‡ªåŠ¨ä¿®å¤è¿ç»­å¤±è´¥** - å•ä¸ªçŠ¶æ€è¿ç»­å¤±è´¥5æ¬¡æˆ–æ€»å¤±è´¥æ¬¡æ•°è¶…è¿‡10æ¬¡æ—¶ï¼Œå‘é€ ERROR/CRITICAL çº§åˆ«å‘Šè­¦
4. âœ… **äº¤æ˜“æ‰€APIä¸å¯ç”¨** - è¿ç»­ä¸å¯ç”¨è¶…è¿‡5åˆ†é’Ÿæ—¶ï¼Œå‘é€ ERROR çº§åˆ«å‘Šè­¦

**é…ç½®æ–¹æ³•**ï¼š

1. åœ¨ `.env` æ–‡ä»¶ä¸­æ·»åŠ é‚®ä»¶é…ç½®ï¼ˆå‚è€ƒ `.env.example`ï¼‰ï¼š

   ```bash
   # SMTP æœåŠ¡å™¨é…ç½®
   SMTP_HOST=smtp.gmail.com
   SMTP_PORT=587
   SMTP_USER=your_email@gmail.com
   SMTP_PASS=your_email_password_or_app_password
   
   # å‘Šè­¦æ¥æ”¶é‚®ç®±
   ALERT_EMAIL_FROM=your_email@gmail.com
   ALERT_EMAIL_TO=alert_receiver@example.com
   ```

2. é‡å¯ç³»ç»Ÿåä¼šè‡ªåŠ¨åˆå§‹åŒ–é‚®ä»¶æœåŠ¡

   ```bash
   npm start
   ```

3. å¦‚æœæœªé…ç½®é‚®ä»¶ï¼Œç³»ç»Ÿä¼šè®°å½•æ—¥å¿—ä½†ä¸å‘é€é‚®ä»¶

**é‚®ä»¶å‘Šè­¦ç‰¹æ€§**ï¼š

- âœ… è‡ªåŠ¨å»é‡ï¼šåŒç±»å‘Šè­¦5åˆ†é’Ÿå†…åªå‘é€ä¸€æ¬¡ï¼Œé¿å…é‚®ä»¶è½°ç‚¸
- âœ… ç¾åŒ–æ ¼å¼ï¼šHTMLé‚®ä»¶æ¨¡æ¿ï¼ŒåŒ…å«å‘Šè­¦çº§åˆ«ã€æ—¶é—´ã€è¯¦ç»†ä¿¡æ¯
- âœ… å¤šçº§åˆ«ï¼šINFOã€WARNINGã€ERRORã€CRITICAL å››ä¸ªçº§åˆ«
- âœ… å…¼å®¹æ€§ï¼šæ”¯æŒ Gmailã€QQã€163ã€Outlook ç­‰ä¸»æµé‚®ç®±
- âœ… å¯é€‰åŠŸèƒ½ï¼šä¸é…ç½®é‚®ä»¶ä¸å½±å“ç³»ç»Ÿæ­£å¸¸è¿è¡Œ

**æµ‹è¯•é‚®ä»¶é…ç½®**ï¼š

```typescript
// åœ¨ä»£ç ä¸­æµ‹è¯•ï¼ˆä»…ç”¨äºè°ƒè¯•ï¼‰
import { emailAlertService } from './utils/emailAlert';
await emailAlertService.testEmail();
```

### åç»­ä¼˜åŒ–æ–¹å‘

1. **ä¿®å¤ç­–ç•¥ä¼˜åŒ–** - æ ¹æ®å®é™…è¿è¡Œæƒ…å†µï¼ŒæŒç»­å®Œå–„ä¿®å¤é€»è¾‘
2. **æ€§èƒ½ä¼˜åŒ–** - å¦‚æœæ•°æ®é‡å¢å¤§ï¼Œè€ƒè™‘ä¼˜åŒ–æŸ¥è¯¢å’Œç´¢å¼•
3. **æ›´å¤šæ£€æŸ¥é¡¹** - æ ¹æ®å®é™…è¿è¡Œå‘ç°çš„é—®é¢˜ï¼Œå¢åŠ æ£€æŸ¥ç»´åº¦

---

## é™„å½•ï¼šæ•…éšœæ’æŸ¥æŒ‡å—

### é—®é¢˜1ï¼šå‘ç°ä¸ä¸€è‡´çŠ¶æ€

```bash
# 1. æŸ¥çœ‹è¯¦æƒ…
sqlite3 .voltagent/trading.db "SELECT * FROM inconsistent_states WHERE resolved=0;"

# 2. æ‰‹åŠ¨ä¿®å¤ï¼ˆå¦‚æœè‡ªåŠ¨ä¿®å¤å¤±è´¥ï¼‰
# æŸ¥è¯¢äº¤æ˜“æ‰€çœŸå®çŠ¶æ€
# è¡¥å……æ•°æ®åº“è®°å½•æˆ–åˆ é™¤é”™è¯¯è®°å½•

# 3. æ ‡è®°ä¸ºå·²è§£å†³
sqlite3 .voltagent/trading.db "UPDATE inconsistent_states SET resolved=1, resolved_at=datetime('now'), resolved_by='manual', resolution_notes='æ‰‹åŠ¨ä¿®å¤' WHERE id=?;"
```

### é—®é¢˜2ï¼šå¥åº·æ£€æŸ¥æŠ¥å‘Šå¼‚å¸¸

```bash
# æŸ¥çœ‹å®Œæ•´æ—¥å¿—
tail -f logs/pm2-out.log | grep "å¥åº·æ£€æŸ¥"

# å¸¸è§é—®é¢˜:
# - å­¤å„¿æ¡ä»¶å•: è‡ªåŠ¨æ¸…ç†ä¼šå¤„ç†
# - æŒä»“ä¸ä¸€è‡´: æ£€æŸ¥äº¤æ˜“æ‰€æ˜¯å¦çœŸå®å­˜åœ¨æŒä»“
# - APIä¸å¯ç”¨: æ£€æŸ¥ç½‘ç»œå’ŒAPIå¯†é’¥
```

### é—®é¢˜3ï¼šè‡ªåŠ¨ä¿®å¤å¤±è´¥

```bash
# æŸ¥çœ‹ä¿®å¤æ—¥å¿—
tail -f logs/pm2-out.log | grep "è‡ªåŠ¨ä¿®å¤"

# å¯èƒ½åŸå› :
# - äº¤æ˜“æ‰€APIè¿”å›æ•°æ®ä¸å®Œæ•´
# - æ•°æ®åº“çº¦æŸå†²çª
# - ä¿®å¤é€»è¾‘ä¸åŒ¹é…å½“å‰çŠ¶æ€

# éœ€è¦äººå·¥ä»‹å…¥
```

### é—®é¢˜4ï¼šé‚®ä»¶å‘Šè­¦æœªæ”¶åˆ°

```bash
# 1. æ£€æŸ¥é‚®ä»¶æœåŠ¡æ˜¯å¦åˆå§‹åŒ–
tail -f logs/pm2-out.log | grep "é‚®ä»¶å‘Šè­¦"

# 2. æ£€æŸ¥ç¯å¢ƒå˜é‡é…ç½®
echo $SMTP_HOST $SMTP_PORT $SMTP_USER

# 3. æµ‹è¯•é‚®ä»¶é…ç½®ï¼ˆåœ¨ Node.js REPL ä¸­ï¼‰
node
> import('./dist/index.js').then(m => m.emailAlertService.testEmail())

# å¸¸è§é—®é¢˜:
# - ç¯å¢ƒå˜é‡æœªé…ç½®æˆ–é…ç½®é”™è¯¯
# - SMTP å¯†ç é”™è¯¯ï¼ˆGmailéœ€è¦ä½¿ç”¨åº”ç”¨ä¸“ç”¨å¯†ç ï¼‰
# - ç½‘ç»œæ— æ³•è®¿é—®SMTPæœåŠ¡å™¨
# - é‚®ä»¶è¢«è¿‡æ»¤åˆ°åƒåœ¾ç®±
```
